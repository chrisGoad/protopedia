

/* When a Object has a method called update, the state of that node is maintained by application of that method
 * when there are changes. Some nodes within the tree might be generated by update, and in that case, the node is marked computed.
 * Independently, the atomic values of some properties might be set by update, and in that case, the property might me marked computed.
 * Typically, the latter marking is made on the prototype (eg, if width of a bar is computed, this fact is declared in the prototype of the bar)
 */


pj.declareComputed = function (node) {
  node.__computed = 1; 
  return node;
}

pj.defineFieldAnnotation("computed");  // defines __setComputed and __getComputed

pj.isComputed = function (node,k,id) {
  let d = id?id:0;
  if (d > 20) {
     pj.error('update','stack overflow'); 
  }
  if (!node) return false;
  if (node.__computed) return true;
  if (k && node.__getcomputed(k)) {
    return true;
  }
  
  return pj.isComputed(node.__get('__parent'),undefined,d+1);
}



pj.updateErrors = [];
pj.debugMode = 1; // no tries in debug mode, to ease catching of errors
pj.updateCount = 0;
pj.catchUpdateErrors = false;// useful off for debugging;

pj.updateErrorHandler = function (node,e) {
  debugger;
  let msg = e.message + ' in update';
  let src = node.__sourceUrl;
  if (src) {
    msg += ' from '+src;
  } else {
    let name = node.__name;
    if (name) {
      msg += ' of '+name;
    }
  }
  pj.error(msg);
  pj.displayError(msg);
 // pj.updateErrors.push(e.message);
}

pj.preUpdateHooks = [];

pj.Object.__update = function () {
  if (pj.updateFilter  && !pj.updateFilter(this)) {
    return;
  }
  pj.preUpdateHooks.forEach((f) => {f(this)});
  if (this.update ) {
    pj.log('update','__updating ',this.__name);
    debugger;
    if (pj.catchUpdateErrors) {
      try {
        this.update();     
      } catch(e) {
        pj.updateErrorHandler(this,e);
        return;
      }
    } else {
      this.update();
    }
    this.__newData = 0;
    if (this.__updateCount) {
      this.__updateCount++;
    } else {
      this.__updateCount = 1;
    }
  }
}
pj.forEachPart = function (node,fn,filter) {
  pj.forEachTreeProperty(node,function (child) {
    if (child.update) {
      if (!filter || filter(child)) {
        fn(child);
      }
    } else {
      pj.forEachPart(child,fn,filter);
    }
  });
}

pj.partsFromSource = function (src) {
  let rs = pj.Array.mk();
  pj.forEachPart(function (part) {
    if (pj.fromSource(src)) {
      rs.push(src);
    }
  })
  return rs;
}
pj.partAncestor = function (node) {
  let rs = node;
  while (1) {
    if (rs.update) {
      return rs;
    }
    let pr = rs.__get('__parent');
    if (pr) {
      rs = pr;
    } else {
      return rs;
    }
  }
}
  


pj.updateParts = function (node,filter) {
  let updateLast = [];
  pj.forEachPart(node,function (node) {
    if (node.__updateLast) {
      updateLast.push(node);
    } else {
      node.__update();
    }
  },filter);
  updateLast.forEach(function (node) {
    node.__update();
  });
}

pj.updateInheritors = function (node,filter) {
  pj.forInheritors(node,function (x) {x.__update()},filter);
}

pj.updateRoot = function (filter) {
  if (pj.root && pj.root.update && (!filter || filter(pj.root)))  {
    pj.root.__update();
  } else if (pj.root) {
      pj.updateParts(pj.root,filter);
  }
}

pj.updateAncestors = function (node) {
  if (node) {
    node.__update();
    pj.updateAncestors(node.__parent);
  }
}


pj.resetArray = function (node,prop) {
  let child = node.__get(prop); 
  if (child) {
    pj.removeChildren(child);
  } else {
    child = node.set(prop,pj.Array.mk());
  }
  return child;
}

pj.resetComputedArray = function (node,prop) {
  let child = pj.resetArray(node,prop);
  pj.declareComputed(child);
  return child;
}


// create a new fresh value for node[prop], all set for computing a new state

pj.resetComputedObject = function (node,prop,factory) {
  let value = node.__get(prop),
    newValue;
  if (value) {
    pj.removeChildren(value);
  } else {
    if (factory) {
      newValue = factory();
    } else {
      newValue = pj.Object.mk();
    }
    value = node.set(prop,newValue);
  }
  pj.declareComputed(value);
  return value;
}
 
 //pj.resetComputedDNode = pj.resetComputedObject; // old name
 
/* if stash is nonnull, save the computed nodes to stash
 * the stash option is used when saving an item, but wanting its state to persist after the save
 */

pj.removeComputed = function (node,stash) {
  let thisHere = this;
  let  found = 0;
  pj.forEachTreeProperty(node,function (child,prop) {
    if (prop == "__required") {
      return;
    }
    if (child.__computed) {
      found = 1;
      if (stash) {
        stash[prop] = child;
      }
      if (pj.Array.isPrototypeOf(child)) {
        node.set(prop,pj.Array.mk());
      } else {
        child.remove();
      }
    } else {
      let stashChild;
      if (stash) {
        stashChild = stash[prop] = {__internalNode:1};
      } else {
        stashChild = undefined;
      }
      if (pj.removeComputed(child,stashChild)) {
        found = 1;
      } else {
        if (stash) {
          delete stash[prop];
        }
      }
    }
  });
  return found;
}


pj.restoreComputed = function (node,stash) {
  for (let prop in stash) {
    if (prop === '__internalNode') continue;
    let stashChild = stash[prop];
    if (!stashChild) {
      return;
    }
    if (stashChild.__internalNode) {
      pj.restoreComputed(node[prop],stashChild);
    } else {
      node[prop] = stashChild;
    }
  }
}

// the signature of an object tells which of its atomic properties are open for reading and writing
// There is no enforcement. The signature determines the behavior of the transferState operator.


pj.set("Signature",pj.Object.mk()).__namedType();

// if value is a string or item, treat it as the type
pj.Signature.addProperty = function (prop,access,value) {
  let vl;
  if ((typeof(value) === 'string') || pj.Object.isPrototypeOf(value )) {
    vl = pj.lift({access:access,type:value});
  } else {
    vl = pj.lift(value);
  }
  this.set(prop,vl);
}

pj.Signature.mk = function (writables,readables) {
  let prop,access;
  let rs = Object.create(pj.Signature);
  for (prop in writables) {
    rs.addProperty(prop,'W',writables[prop]);
  }
  if (readables) {
    for (prop in readables) {
      rs.addProperty(prop,'W',readables[prop]);
    }   //code
  }
  return rs;
}

pj.transferState = function (dest,src,ownOnly) {
  let srcsig = src.__signature;
  let destsig = dest.__signature;
  if (srcsig && destsig) {
    pj.forEachTreeProperty(destsig,function (child,prop) {
      let destp = destsig[prop];
      let pv;
      if (destp && (destp.access === 'W')) {
        pv = (ownOnly)?src.__get(prop):src[prop];
        if (pv !== undefined) {
          dest[prop] = pv;
        }
      }
    });
    dest.__update();
    return dest;
  }
}


pj.replacePrototype = function (target,newProto) {
  let oldProto = Object.getPrototypeOf(target);
  let rs  = newProto.instantiate();
  pj.transferState(rs,target);
  let nm = target.__name;
  let parent = target.__parent;
  let ta = parent.textarea;
  //ta.remove();
  //target.remove();
  parent.set(nm,rs);
  rs.__update();
  rs.__draw();
  ta.__bringToFront();
  //parent.set('textarea',ta);
  //ta.__draw();
  return rs;
}

/* pj.replacements is initialized from the replacement data base, and maps paths to replacement descriptions
 * A replacement description has the form: {svg:<url>,replacement:<url>}
 */

