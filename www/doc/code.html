{{boiler00}}
{{boiler2}}
<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/2.1.0/jquery.min.js"></script>

<script>
var documentReady = 0;
var initPage = function () {

    $('#openTreeDetails').click(function () {
        $('#treeDetails').show();
    });
     $('#closeTreeDetails').click(function () {
        $('#treeDetails').hide();
    });
       $('#openInstantiateDetails').click(function () {
        $('#instantiateDetails').show();
    });
    $('#closeInstantiateDetails').click(function () {
        $('#instantiateDetails').hide();
    });
}


$('document').ready(function () {
  documentReady = 1;
  initPage();
});
</script>



  
<div class="pageTitle">Coding Guide</div>

<div class="tableOfContents"> 
    <div class="contentsLine"><a href="#quickStart">1. Quick Start</a></div>
     <div class="contentsLine"><a href="#components">2. Components</a></div>
   <div class="contentsLine"><a href="#codeStructure">3. Code Structure</a></div>
     <div class="contentsLine"><a href="#trees">4. Trees</a></div>
      <div class="contentsLine"><a href="#instantiation">5. Instantiation and Serialization</a></div>
   <div class="contentsLine"><a href="#nonews">6. No news</a></div>  
  <div class="contentsLine"><a href="#svg">7. SVG</a></div>
   <div class="contentsLine"><a href="#conventions">8. Naming Conventions</a></div>
    <div class="contentsLine"><a href="#controllers">9. Controllers</a></div>
      <div class="contentsLine"><a href="#dataBinding">10.  Data Binding</a></div>
        <div class="contentsLine"><a href="#spreads">11. Spreads</a></div>
           <div class="contentsLine"><a href="#externalData">12. External Data</a></div>
         <div class="contentsLine"><a href="#dataFormat">13. Data Format</a></div>


</div>

<p>
<div class="section" id="quickStart">1. Quick Start </div>
<p> Beginning with a very simple example: </p>

<a href="http://prototypejungle.org/ui?source=http://prototypejungle.org/sys/repo3|example/two_rectangles.js">
  http://prototypejungle.org/ui?source=http://prototypejungle.org/sys/repo3|example/two_rectangles.js
</a>

<p>which produces this image: <img style ="position:relative;top:10px;" src="/images/logo.svg"  width="50" height="30"/></p>

<p> The source file
<a href="http://prototypejungle.org/sys/repo3/example/two_rectangles.js">http://prototypejungle.org/sys/repo3/example/two_rectangles.js</a> contains
the code</p>

<pre><code>
(function () {
var item = pj.svg.Element.mk('&lt;g/&gt;');
// the prototype for the two rectangles, r1, and r2
item.set("rectP", pj.svg.Element.mk(
  '&lt;rect  fill="blue" stroke="black" stroke-width="5" x="0" y="0" width="100" height="100"/&gt;'
).__hide());
item.set("r1",item.rectP.instantiate()).__show();
item.r1.fill="green";
item.set("r2",item.rectP.instantiate()).__show();
item.r2.x = 120;
pj.returnValue(undefined,item);
})();
</pre></code>

<p>The source file can come from anywhere on the web. So, you can use the prototypejungle UI with your own code,
assuming you have web-posting capability.<!--
Of course, this requires posting the code somewhere on the web. You can do this in many ways, but
<a href="hastebin.com">hastebin</a> is a simple choice - after save, select "just text" in the hastebin button box.--> </p>
<p>
The PrototypeJungle implementation is installed under one global variable, 
<span class="codeWord">prototypeJungle</span>. 
A shorter synonym for that global, <span class="codeWord">pj</span> is also made available. If you need <span class="codeWord">pj</span> for other purposes,
it can be freed by calling <span class="codeWord">prototypeJungle.noConflict()</span>
(this is analogous to <a href="https://api.jquery.com/jquery.noconflict/">jQuery.noConflict()</a>, which frees up $). </p>
</p>

<p><span class="codeWord">pj.svg.Element.mk</span> creates a prototype tree from
<a href="https://developer.mozilla.org/en-US/docs/Web/SVG">SVG</a> markup.
In what follows, prototype trees will be referred to as "items".</p>

<p>For any <span class="codeWord">item</span>, </p>

<pre><code>
item.set(name,ch);
</code></pre>

<p>assigns <span class="codeWord">ch</span> as the child of <span class="codeWord">item</span>  with the given <span class="codeWord">name</span>.</p>

<pre><code>
item.instantiate();
</pre></code>

<p>
is a <a href="http://prototypejungle.org/doc/tech.html#instantiate">fundamental operation</a> in PrototypeJungle:
it  is the analog of <span class="codeWord">Object.create</span>, but works for trees of arbitrary depth.
</p>

<p>
In the <a href="http://prototypejungle.org/doc/tech.html#components">component system</a>, <span class="codeWord">pj.return(errorMessage,item)</span> is used to return
<span class="codeWord">item</span> as the value of the current component.
</p>
<p>
So, now we can see that two_rectangles.js builds the small prototype tree:
</p>
<pre><code>
    root
    /  \
   r1   r2
</pre></code>


<p> A final detail: 
the source argument for <span class="codeWord">prototypejungle.org/ui</span> has the form
<span class="codeWord">...sys/repo3|example...</span> rather than simply
<span class="codeWord">...sys/repo3/example...</span> (Note the "|" rather than "/" between
<span class="codeWord">repo3</span> and <span class="codeWord">example</span>.) This serves to pick out a <i>repo</i> (repository)
within which the given component resides;
this repo
is what appears before the <b>|</b>, and the repo-relative address is after the <b>|</b>.
The operation which loads external components, <span class="codeWord">pj.require</span>, allows these components to be
referred to
<a href="tech.html#repo">relative to the repo</a> of the containing component.
An example of this appears <a href="#require">just below</a>.</p>

<p>
<span class="codeWord">prototypejungle.org/ui</span>  displays items in the user interface, where items
and their prototypes can be adjusted.
Such items can also be displayed outside of the ui, as illustrated in the file
<a href="http://prototypejungle.org/sys/repo3/example/standalone.html">http://prototypejungle.org/sys/repo3/example/standalone.html</a>.
Note (via <i>view source</i>) that
the coding environment is set up in a  different way, but that the construction of the item is identical.
The same standalone code is available at
<a href = "http://jsfiddle.net/prototypejungle/fvjuu8uo">jsfiddle</a></p>
</p>

<div class="section" id="components">2. Components </div>

<p>Here is another example, in which an item is built from components loaded from an external source:<br/>
<a href="http://prototypejungle.org/ui?source=http://prototypejungle.org/sys/repo3|example/two_arrows.js">
http://prototypejungle.org/ui?source=http://prototypejungle.org/sys/repo3|example/two_arrows.js</a></p>
The source file  contains
the code</p>
<pre><code id="require">

pj.require('shape/arrow1.js',function (error,arrowPP) {
  var item = pj.svg.Element.mk('&lt;g/&gt;');
  item.set("arrowP",arrowPP.instantiate()); 
  item.set("arrow1",item.arrowP.instantiate()); 
  item.set("arrow2",item.arrowP.instantiate());
  item.arrow2.set("end1",pj.geom.Point.mk(100,180));
  item.update = function () {
    this.arrow1.update();
    this.arrow2.update();
  }
  pj.returnValue(undefined,item);
});
</code></pre>
<p><span class="codeWord">pj.require('shape/arrow1.js',function (error,arrowPP) { ...</span> binds
<span class="codeWord">arrowPP</span> to the
component defined in <span class="codeWord">shape/arrow1.js</span> within the same repo.
Note that the arrow prototype <span class="codeWord">arrowPP</span> loaded from <span class="codeWord">arrow.js</span> is first instantiated to
<span class="codeWord">arrowP</span>, and that <span class="codeWord">arrowP</span>
(unlike <span class="codeWord">arrowPP</span>) is internal
to the new item. Then <span class="codeWord">arrowP</span> is instantiated twice to create the two visible arrows. This makes
<span class="codeWord">arrowP</span> available for
manipulation, where <span class="codeWord">arrowPP</span> would not be. </p>
<p>Many items have an <span class="codeWord">update</span> method. Generally,
this method brings the object into its intended form based on its
properties. For example, the update method for an arrow sets the geometry of its shaft and head segments to match
its specified length, end points, and head parameters. Often an item which has the form of an SVG group of parts is
updated simply by updating those parts. Such is the case in this example. </p>






<div class="section" id="codeStructure">3. Code Structure </div>

<p>The PrototypeJungle implementation has three levels. First, there  is the core, in which prototype trees
and their basic operations, including serialization and instantiation, are defined. The second level supports
prototype trees in the context of 2d graphics generally and infographics in particular. <!--
Protototypes are provided for 2d graphical shapes and their operations, and for sets of infographic marks
with data binding. -->This level of the implementation relies on
<a href="https://developer.mozilla.org/en-US/docs/Web/SVG">SVG</a>. The third level implements
a prototype-enabled 
user interface. You see this interface in <a href="http://prototypejungle.org/ui">PrototypeJungle/ui</a></p>

<p>These three levels of code can be found at 
<a href="http://prototypejungle.org/js/pjcore-0.9.2.js">pjcore-0.9.2.js</a>, <a href="http://prototypejungle.org/js/pjdom-0.9.2.js">pjdom.0.9.2.js</a>
 and <a href="http://prototypejungle.org/js/pjui-0.8.2.js">pjui-0.8.2.js</a>, respectively.
pjdom includes the PrototypeJungle core,
so that PrototypeJungle with geometric, SVG, and infographic support may be loaded with just one line:</p>

<pre><code>
&lt;script src="http://prototypejungle.org/js/pjdom-0.9.2.min.js"&gt;&lt;/script&gt;

</code></pre>
<p> For charts, there is a fourth level of code: the code that implements the charts themselves, and their components
such as axes and legends.  The code for these appears in the current prototype repository: http://prototypejungle.org/repo3/charts, and also at github.


<p>Unlike the other levels, which have no
association with any particular web location and could be deployed from anywhere,
pjui is configured specifically to support  the PrototypeJungle web site. Not much will be said about the ui layer in this document.</p>


<div class="section" id="trees">4. Trees</div>

<p> The internal nodes in prototype trees  inherit from prototypes pj.Array 
for sequential, zero-based arrays, and pj.Object  for objects which are not arrays.  

</p>

<pre><code>  
pj.Object.mk();
</code></pre>

<p> creates a  new <span class="codeWord">Object</span>, and</p> 
<pre><code>
pj.Array.mk();
</code></pre>
<p> a new <span class="codeWord">Array</span>.</p>
<p> 
<pre><code>
object.set(name,child);
</code></pre>

<p>assigns <span class="codeWord">child</span> as a child of 
<span class="codeWord">object</span> with name <span class="codeWord">name</span>.
If <span class="codeWord">child</span> is an Object or Array, this results in setting special properties:
<span class="codeWord">child.__parent === object</span>, and <span class="codeWord">child.__name === name</span>.</p>

<p> For an Array,</p>
<pre><code>
array.push(child);
</code></pre>

<p>Pushes <span class="codeWord">child</span> onto the end of  <span class="codeWord">array</span>,
and assigns <span class="codeWord">array</span> as the parent of <span class="codeWord">child</span>. Then,
<span class="code">array[array.length-1] === child</span>, and if <span class="codeWord">child</span> is an Object or Array,
<span class="code">child.__name === array.length-1</span>,
and <span class="code">child.__parent === object</span>. Arrays are always sequential, zero-based arrays.
</p>

<pre><code>
pj.lift(obj);
</code></pre>

<p>takes an "ordinary" Javascript tree such as one expressable in JavaScript object notation,
and turns it into the PrototypeJungle kind of tree. 
For example: </p>
<pre><code>
pj.lift({a:2,b:["a",4]});
</code></pre>

<p> will produce a Object/Array tree with matching structure. "item" is another term for Object/Array tree. </p>


<p>Click <span class="clickable" id="openTreeDetails">here</span> for an example of tree construction and manipulation.</p>
<div id="treeDetails" class="techDetails">
<div class="close" id="closeTreeDetails">X</div>



<pre><code>
var root = pj.Object.mk();
var aa = pj.Object.mk();
var bb = pj.Array.mk();

root.set("a",aa); // adds aa as a child named "a" of root
root.set("b",bb);

// __name and __parent "glue the tree together".
bb.__name;
==>b
bb.__parent === root;
==>true

// let's add some atomic data 
aa.x = 5;  // set is not needed for atomic data or functions
aa.f = function (x) {return x*x;}

// now for an Array
var cc = pj.Array.mk();
bb.set("c",cc);

cc.push(pj.Object.mk().set("z",45));
cc.push(5);

</code>
</pre>
<p>this yields:</p>
<pre><code>
          --root--
        /          \
       a            b
      / \            \
     x   f            c
    /     \            \
   5    function      [ *, 5]
                       /
                      z
                     /
                    45
   

</code>
</pre>
<p> where * is an Object</p>

<p>
This could also be built with
</p>

<pre><code> 
var root = pj.lift({a:{x:5},b:{c:[{z:45},5]}})
root.a.f = function (x) {return x*x};
</code></pre>


<p>There is nothing wrong with having properties of Objects that reference
nodes in the tree  other than children,  as in </p> 

<pre><code>
a.xx = b; 
</code></pre>
 
<p>in the above example.Then xx is a cross-tree reference.</p>
<p><i>Restriction on names</i>: names may include only letters, numerals, and the underbar, and may not start with a numeral.</p>
</div>

<div class="section" id="instantiation">5. Instantiation and serialization</div>
<pre><code> 
inode = node.instantiate();
</code></pre>

<p> builds an instantiation of node; a tree which has the same structure as node, but inherits primitive
data and functions from root via prototypical inheritance. (Details <a href="/indexd.html#instantiate">here</a> and
<a href="/devdoc/tech.html#instantiate">here</a>)</p>
<p>Serialization is performed by: 
<pre><code> 
s = pj.stringify(node);
</code></pre>

<p> as described <a href="/devdoc/tech.html#serialization">here</a>.</p>


<div class="section" id="nonews">6. No news</div>
<p> Nodes are constructed with <span class="codeWord">pj.Object.mk()</span> and <span class="codeWord">pj.Array.mk()</span>, rather than via the use of a "new". The definition of the mk method for Object is:

<pre><code>
pj.Object.mk = function () {
  return Object.create(pj.Object);
}
</code></pre>


<p>Recall that <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create">Object.create</a>(X) creates a new object with X as prototype.
</p>


<p><span class="codeWord">Object</span> is introduced simply with:</p>

<pre><code>
pj.Object = {};
</code></pre>

<p>and <span class="codeWord">Array</span>  with:</p>


<pre><code>
pj.Array = [];
</code></pre>

<p>
<span class="codeWord">pj.Object</span> itself serves as the prototype for instances.  In the more conventional pattern, <span class="codeWord">pj.Object</span> would be a function, and
the prototype property of that function, not Object itself, would be the  prototype for the instances generated via the new operator
(note that if <code>F = function (){}, new F()</code> is equivalent
to <code>Object.create(F.prototype)</code>)
</p>
<p>
The <span class="codeWord"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new">
function, function.prototype, new</a></span> &nbsp; pattern has been available in JavaScript all along, whereas the  more direct <span class="codeWord">Object.create</span> was introduced in recent years, in version 1.8.5. PrototypeJungle
employs the newer pattern, not so much for its intrinsic  simplicity (though that's nice), but because this way of doing things has a major
simplifying effect on the entire PrototypeJungle code base. </p>

<p> You will never see a "new" anywhere in the code. The convention is that for prototype  <span class="codeWord">X</span>, <span class="codeWord">X.mk</span> is the creator/initializer (which may take arguments).</p>

<div class="section" id="svg">7.  SVG  </div>
<p>We have seen SVG Elements before, as in the line</p>
<pre><code>
  var rect = pj.svg.Element.mk(
    '&lt;rect  fill="blue" stroke="black" stroke-width="5" x="0"   y="0" width="100" height="100"/&gt;').__hide();
</code></pre>

<p> in the quick start section. 
Generally, svg.Element.mk(markup); creates an object that inherits from the prototype svg.Element, which in turn
inherits from pj.Object. Its  content
as an SVG element is as specified by the markup. At this stage, only some of the tags are supported:
g, line, polyline, circle, rect, text, g and svg.
</p>
<div class="section" id="conventions">8.  Naming conventions</div>
<p>Developers  perform their work by defining new properties and methods for pj.Object, pj.Array, and
pj.svg.Element.
Thus, the issue arises of avoiding name collisions with methods on these types that PrototypeJungle
itself defines. A primitive scheme addresses this issue: except for a very small collection of basic methods,
PrototypeJungle uses names that start with a double underbar (__). So, name collisions
will be avoided if developers never use double-underbar prefixes for the  properties and methods that they
introduce for their own purposes.
Of course, the
few basic methods should not be trampled on either, but it is a very short list, namely:
It is not quite right to call the double underbarred symbols <i>private</i>, since, as you will see,
several of them
(eg __getExtent to take a random example) have designated public purposes. </p>
<div class="section" id="controllers">9.  Controllers </div>
<p>Notice that when you select a bar in the  bar chart, and then click the up button, a box with draggable handles appears
which allows you to resize the chart. Also, when you select one of the arrows in the component example, handles appear that allow
modification of the arrow. These are dubbed "controllers",  can be implemented for any item, and come in two varieties "resizer"
and "custom".  To implement a resizer, two methods, __getExtent(), and __setExtent(extent) should be defined. This is all that is needed: if these
methods are present, the resizing box with its handles will appear in the UI whenever that item is selected. __getExtent takes no arguments,
and returns a geom.Point, while __setExtent takes a geom.Point representing the new extent as input, and returns nothing. See the bar chart code for an example.
</p>
<p>To define a custom control, the two methods needed are __controlPoints(), and __updateControlPoint(index,pos).
__controlPoints should return a pj.Array of geom.Point (s). When the item is selected, handles will appear
at the indicated positions (the points should be given relative to the item's own origin). Then, when dragging takes
place, __updateControlPoint(index,pos) is called at each moment of dragging, with index set to the index
of the point which generated the handle being dragged, and pos is its new position. It is the responsibility of
__updateControlPoint to update and redisplay the item as appropriate given the new  handle position. The arrow item
provides an example.</p>
<p>If all four methods are defined, the item will be displayed with both a resize box, and the custom handles.</p>
</p>
<div class="section" id="dataBinding">10.  Data Binding </div>


<p id="setData"> 
Data binding is done in a very simple way, amounting to no more than two conventions.  The first is that the data associated
with any node N is held in the field N.data. The second is that the method N.update, if any, has the job of causing the state of N to
reflect the data. The basic data binding operator is (in essence):</p>

<pre>
Object.setData = function (d) {
  this.set('data',pj.lift(d));if (this.update) this.update();
}
</pre>
<p> (pj.lift is a no-op when applied to an object which is already in Object/Array form.) </p>
<div class="section" id="spreads">11. Spreads</div>

<p>A pj.Spread represents a collection of items instantiated from the same prototype. Usually, the data associated
with a spread is a series, and the individual members of the spread are bound to the elements of
series.  For example, in the bar chart example, the set of bars is represented as a spread, and the data
is a series of metal densities. The individual bars are bound to the elements of this series.
(In infographics, it is conventional to refer to the members of a spread used in this way as "marks".)
 Consider:
</p>

<pre>
m = pj.Spread.mk(mProto);
</pre>

<p>This creates a spread whose members are instantiated from  mProto.
Suppose that m is bound to the following series:</p>

<pre>
{'elements':[3,4,5]]}
</pre>

<p>The general format for data series is described <a href="#dataFormat">below</a>.</p>
<p>A spread should also have a binder method, which binds elements of the series to the members of the spread.
(The binder method is also
passed the index of the member in the set, and the size of the set)
The default update method for a spread works as outlined above:
if a series has been bound to the spread, then
for each element e of the series, the prototype (eg mProto) is instantiated, and then e is bound to the instance using the binder method.
Here is the code for a
<a href="http://prototypejungle.org/ui?source=http://prototypejungle.org/sys/repo3|example/simple_bar_chart.js">simple bar chart</a>:</p>

<pre>
(function () {
var item = pj.svg.Element.mk('&lt;g/&gt;');
// barP is the prototype for bars
item.set("barP",pj.svg.Element.mk(
  '&lt;rect fill="rgb(39, 49, 151)" stroke="black" stroke-width="3"  height="50"/&gt;'));
item.barP.scale = 100;
item.set("marks",pj.Marks.mk(item.barP));
item.marks.binder = function (mark,data,index,size) {
  mark.width = mark.scale * data; // the width of the bar set from the data
  mark.y = (size - index) * 60; // stack the bars from bottom to top
}
item.update = function () {
  // send the top level data down to the mark set for display
  this.marks.setData(({"elements":[3,4,1]}));
  this.marks.update();
}
pj.returnValue(undefined,item);
})();
</pre>
<!--
<p> Here's a walk-through of what happens. When the item is loaded, the update method is run. This first binds the data (a series) to the mark set. The mark set's
update method in turn instantiates barP once for each element e of the series, and binds that element to the instance, which has the effect
of setting the width of the bar to e, scaled by barP.scale. The binder also sets the y coordinate of each bar
in such a way that the bars are stacked.
</p>-->


<div class="section" id="externalData">12.  External Data </div>

<p>Data can be loaded from external sources using the component mechanism, as follows: (at
<a href="http://prototypejungle.org/ui/source=http://prototypejungle.org/sys/repo3|example/external_data0.js">
  http://prototypejungle.org/sys/repo3/example/external_data0.js
</a>)


<pre><code>
pj.require('example/simple_bar_chart.js','example/sample_data0.js',function (erm,graphP,data) {
  var item = pj.svg.Element.mk('&lt;g/&gt;');
  item.set("graph",graphP.instantiate());
  item.graph.setData(data);
  pj.returnValue(undefined,item);
});
</code></pre>

<p> where http://prototypejungle.org/sys/repo3/example/sample_data0.js contains: </p>

<pre><code>
pj.returnValue(undefined,{"elements":[1,2,4,8]});
</code></pre>


<p>Alternatively, for each item with a  dataSource property, the data appearing at the indicated location is automatically
loaded and bound to the item at initialization. Here is an example, whose effect is the same as produced by the example
just above (at
<a href="http://prototypejungle.org/ui?source=http://prototypejungle.org/sys/repo3|example/external_data1.js">
  http://prototypejungle.org/sys/repo3/example/external_data1.js
</a>)

<pre><code>
pj.require('example/simple_bar_chart.js',function (erm,graphP) {
  var item = pj.svg.Element.mk('<g/>');
  item.set("graph",graphP.instantiate());
  item.dataSource = 'example/sample_data0.js'
  pj.returnValue(undefined,item);
});
</code></pre>

<pre><code>
item.dataSource = '<a href="http://prototypejungle.org/sys/repo2/data/metal_densities.js">http://prototypejungle.org/sys/repo2/data/metal_densities.js'</a>;
</code></pre>

<div  class="section"  id="dataFormat">13. Data Format </div>
<!--
<p> Externally, data should be formated  as a
<a href="https://developers.google.com/chart/interactive/docs/reference#dataparam">Google Charts data object</a>, wrapped by callback as mentioned above.
This is converted
into an object of form <code>{fields:f,elements:e}</code>.
The details of the internal form are beyond the scope of this document.</p>
<p> A minor simplification in the Google Charts format is supported. Namely, column -->
<p> Here is the data for the <a href="http://prototypejungle.org/ui?intro=1&source=http://prototypejungle.org/sys/repo3|example/bar_chart.js">bar graph</a> of metal densities:</p>

<pre>
  {'fields':[
    {'id':'metal','type':'string'},
    {'id':'density','type':'number'}],
  'elements':[['Lithium',0.53],['Copper',9],['Silver',10.5],['Gold',19.3]]})
</pre>

<p>
The fields property describes the meaning of the individual elements in the series. Each series element should be an array with  one element
per field, specifying the values of the fields.
</p>
<!--
When the data elements are bound to the individual marks of a mark set, they are
modified into a standard form taking into account the roles of fields. For example, the element ["Copper",9] is expanded to {domain:"Copper",range:9}, because the first
field is designated as having the role "domain", and the second "range". If a field has no role, its id is used instead.
</p>

<p> Let me comment on the update function within bargraph2:</p>

<pre>


item.update = function () {
  if (!this.data) return;
  var max = this.data.max('range');
  this.axis.set('dataBounds',pj.geom.mkInterval(0,max));
  this.axis.update();
  this.bars.setData(this.data);
  this.labels.setData(this.data);
}

</pre>

<p>Note that update works by setting  parameters of its parts, and then
binding data to those parts.</p>


<p id="categories">Mark sets provide special treatment for data with a field with role "category". Namely, for each category, a separate instantiation of the prototype for the
Mark Set is created. Then, for individual elements, the instantiation associated with the category of the element is instantiated again. This allows the group of marks of a given category to
share a prototype, which can be adjusted to taste.</p>
<p>
<a href = "http://prototypejungle.org/inspect?item=/sys/repo0/chart/component/Legend1">/sys/repo0/chart/component/Legend1</a> produces legends naming the categories,
and showing colors associated with them.

<a href="http://prototypejungle.org/inspect?item=/sys/repo0/chart/Bar1">/sys/repo0/chart/Bar1</a> implements bar charting of categorized data. By inspecting its code, you can see the techniques involved.

</p>

<div class="section" id="variants">14. Variants</div>

<p>In the context of the inspector, an item can come into being in two ways. First, it can be built from a code file. Second, it can be  a <i>variant</i>- the
result of interactively  modifying an existing item  and then storing the result with the "Save as Variant" option in the File pulldown.
  </p>
<p>You will notice the effect of these distinctions in some of the operations of the UI.  For example, only code-built items can be rebuilt, but
further variations can be introduced into variants.  You are not allowed overwrite a code-built item with a variant with a simple
save; you must save the variant somewhere else, with "Save as Variant". The UI attempts to find a suitable name for new saves based on these distinctions.But the names  are only suggestions; you can put things where you want.</p>




<div class="section" id="api">15. API </div>
<p>This section supplies a short list of the stable calls  in this proof-of-concept. </p>


<p>Calls are given in the form <code>f(arg1:type1,arg2:type2...)</code> where types are: <code>string, number, Node (Array or Object) </code> or <code>any</code>. When a call
is described in more detail elsewhere in this document, a <a href="">link</a> is supplied.</p>

<div class="apiSection">om</div>

<div class="apiCall">
  <div class="apiCallNm">pj.Object.mk()</div><div class="apiCallDf">Constructor for pj.Object</div>
</div>
<div class="apiCall">
  <div class="apiCallNm">pj.Array.mk()</div>
  <div class="apiCallDf">Constructor for pj.Array</div>
</div>
<div class="apiCall">
  <div class="apiCallNm">pj.Object.addListener( nm:string; fn:function)</div>
 <div class="apiCallDf">Used in PrototypeJungle's simple event system. Documention pending.</div>
</div>
<div class="apiCall">
  <div class="apiCallNm">pj.Object.set(nm:string,vl:any)</div>
 <div class="apiCallDf">Assign vl as the child of <code>this</code></div>
</div>
<div class="apiCall">
  <div class="apiCallNm">pj.Object.remove(vl:Node)</div>
 <div class="apiCallDf">Remove <code>this</code> from the tree in which it appears.</div>
</div>
<div class="apiCall">
  <div class="apiCallNm">pj.Object.instantiate()</div>
 <div class="apiCallDf"><a href="#instantiate">Link</a>.</div>
</div>
<div class="apiCall">
  <div class="apiCallNm">pj.Object.setData()</div>
 <div class="apiCallDf"><a href="#setData">Link</a>.</div>
</div>
<div class="apiCall">
  <div class="apiCallNm">pj.Object.outerUpdate()</div>
 <div class="apiCallDf"> Documention pending.</div>
</div>
<div class="apiCall">
  <div class="apiCallNm">pj.lift(o)</div>
 <div class="apiCallDf"><a href="#lift">Link</a>.</div>
</div>
<div class="apiCall">
  <div class="apiCallNm">pj.treeProperties( nd:Node, includeLeaves:boolean)</div>
 <div class="apiCallDf">Returns an array of the direct properties of <span class="codeWord">nd</span> which are edges of the prototype tree.
 The argument <span class='codeWord'>includeLeaves</span> is self-descriptive.</div>
</div>

<div class="apiCall">
  <div class="apiCallNm">pj.declareComputed(nd:Object)</div>
 <div class="apiCallDf">Declare that <span class="codeWord">nd</span> is generated by computation within an update method. The effect of this
is to delete  <span class="codeWord">nd</span>  when the item is saved; updates are always run as the part of the restore process,
so  <span class="codeWord">nd</span>  will be recomputed on restore. Computed content can be modified in the inspector,  and these modifications will be retained through subsequent
updates, saves, and restores. The implementation keeps track of modifications, 
and, whenever an update is done, reapplies the modifications to the updated state. </div>
</div>


<div class="apiSection">geom</div>

<div class="apiCall">
  <div class="apiCallNm">geom.Point.mk(x:number,y:number)</div><div class="apiCallDf">Constructor for geom.Point, with properties x and y. If x and y are omitted, 0,0 are used.</div>
</div>


<div class="apiCall">
  <div class="apiCallNm">geom.Point.plus(p:geom.Point)</div><div class="apiCallDf">Adds point p to this</div>
</div>


<div class="apiCall">
  <div class="apiCallNm">geom.Point.minus()</div><div class="apiCallDf"><span class='codeWord'> = geom.Point.mk(-this.x,-this.y)</span></div>
</div>

<div class="apiCall">
  <div class="apiCallNm">geom.Point.difference(p:geom.Point)</div><div class="apiCallDf"><span class='codeWord'> = this.plus(p.minus())</span></div>
</div>


<div class="apiCall">
  <div class="apiCallNm">geom.Point.times(v:number)</div><div class="apiCallDf">Scales the point by v</div>
</div>


<div class="apiCall">
  <div class="apiCallNm">geom.Rectangle.mk(corner:geom.Point, extent:geom.Point)</div><div class="apiCallDf">Constructor for geom.Rectangle, with properties corner and extent. For example <code>geom.Rectangle.mk(geom.Point.mk(10,20),geom.Point.mk(5,5))</code> has
  (10,20) as its upper-left corner, and (15,25) as its lower-right corner.</div>
</div>

<div class="apiSection">svg</div>



<div class="apiCall">
  <div class="apiCallNm">svg.Element.mk(s:string)</div><div class="apiCallDf">Constructor for svg Elements. s is markup.</div>
</div>



<div class="apiCall">
  <div class="apiCallNm">svg.Element.bringToFront()</div><div class="apiCallDf">Transfers the element so that it is
  the last in the child list of its parent. This has the effect of displaying the element in front of its siblings.</div>
</div>


<div class="apiCall">
  <div class="apiCallNm">svg.Element.__hide()</div><div class="apiCallDf">Self-explanatory.</div>
</div>


<div class="apiCall">
  <div class="apiCallNm">svg.Element.__show()</div><div class="apiCallDf">If an element has been hidden, change its status to "visible"</div>
</div>




<div class="apiCall">
  <div class="apiCallNm">svg.Element.draw()</div><div class="apiCallDf">Refresh this element. Changes to the PrototypeJungle
  data for an element (and its descendents) are transferred to the svg model. Adding an element to the PrototypeJungle tree
  is not reflected </div>
</div>




<div class="apiCall">
  <div class="apiCallNm">svg.Root.mk(s:DomElement)</div><div class="apiCallDf">Constructor for a root of the svg model (with tag svg). DomElement should be an element on the current page, retrieved eg via document.getElementById("svgDiv"), to which the new
top-level svg element will be added. The content to be displayed should be set as the child named "contents" of this root.</div>
</div>


<div class="apiCall">
  <div class="apiCallNm">svg.Root.fitContents(v:number)</div><div class="apiCallDf">Arrange for the current contents of the
  svg model to appear centered in the viewing div, scaled into a box that is  fraction v of the available area (eg 0.9 if
  you wish at least a 5% boundary around the content.</div>
</div>



<div class="apiCall">
  <div class="apiCallNm">svg.Element.setScale(s:number)</div><div class="apiCallDf">Scale this element by s. This is implemented
  by setting the scale  of the svg transform of this element to s.</div>
</div>


<div class="apiCall">
  <div class="apiCallNm">svg.Element.getScale()</div><div class="apiCallDf">Returns the scale of the svg transform of this element, or 1
  if there is no transform.</div>
</div>


<div class="apiCall">
  <div class="apiCallNm">svg.Element.moveto(p:geom.Point)</div><div class="apiCallDf">Move this element to p. This is implemented
  by setting the translate element of the svg transform of this element to the coordinates of p. (A transform is introduced
  if not already present).</div>
</div>


<div class="apiCall">
  <div class="apiCallNm">svg.Element.getTranslation()</div><div class="apiCallDf">Returns the translate element of the svg transform of this element,
  converted to a geom:Point, or the Point &lt;0,0&gt; if there is no transform.</div>
</div>



<div class="apiCall">
  <div class="apiCallNm">svg.Element.bounds(rt:svg:Element)</div><div class="apiCallDf">Return the bounds, as a geom:Rectangle, of the given Element (and its descendants).  Bounds are given in the coordinates of rt, which should be the element itself, or an ancestor.</div>
</div>


<div class="apiSection">ui</div>

<p>These calls control how data is displayed in the inspector.  They may be included in code intended for use outside the inspector, since
pjdom.0.9.0.js stubs them. </p>


<div class="apiCall">
  <div class="apiCallNm">ui.freeze(nd:Node,props:array of string)</div><div class="apiCallDf">Hide the specified
  properties of nd  in  the inspector's object tab.</div>
</div>

<div class="apiCall">

 <div class="apiCallNm">ui.freeze(nd:Node,props:array of string)</div><div class="apiCallDf">Do not allow the specified
  properties of nd to be modified in the inspector.</div>
</div>


<div class="apiCall">
  <div class="apiCallNm">ui.watch(nd:Node,props:array of string)</div><div class="apiCallDf">When any of the specified 
  properties of the specified node are modified in the inspector, run an update on the top level. </div>
</div>


<div class="apiCall">
  <div class="apiCallNm">ui.setNote(nd:Node,
  prop:string,note:string)</div><div class="apiCallDf">This supports a simple documentation scheme. It associates the given
  note with property prop of nd. In the inspector, prop will appear with a little "?" which, when clicked, will pop the note.
  </div>
</div>


<div class="apiCall">


</div>

<div class="section" id="names">16. Avoiding name conflicts</div>

<p>When you implement a new component  or chart, method names should not conflict with the names of methods
of om.Object, nor svg.Element, since the nodes in the chart or component will inherit from these prototypes. The above API lists the methods of om.Object and svg.Element which are intended for public use. There are additional methods, however, intended for internal
use within the PrototypeJungle code base. A crude but common approach to name-conflict-avoidance is used: these internal methods (and properties) are named with an initial __
(double underbar). So, in developing applications, you should avoid using methond names starting with __. (An exception is access-to but not overwrite-of   "__parent" and "__name", the properties which undergird the prototype tree structure).
 </p>
<div class="section" id="codingDetail">17. A Coding Detail: item methods run in pj scope</div>


<p>In defining an item in the code tab of the inspector, the variables that you introduce at the global level are not accessible within the methods that you
define within the item. For example consider code from 
<a href="http://prototypejungle.org/inspect?item=/sys/repo0/example/BarChart2">/sys/repo0/example/BarChart2</a></p>
<pre>
var  geom = pj.geom;
....
item.update = function () {
  ...
  this.axis.set("dataBounds",pj.geom.mkInterval(0,max));

  ....
  }
</pre>

<p>Why do I write <span class="codeWord">pj.geom.mkInterval(0,max)</span> instead of just
<span class="codeWord">geom.mkInterval(0,max)</span>? 

<p>
The latter will fail, because, despite appearances, update will not run inside the item's global context, and so "geom" will be
an undefined variable when it does. Specifically, functions appearing in items need to be able to run without assuming anything about the
scope, with the single exception that the variables <span class="codeWord">pj</span> and  <span class="codeWord">prototypeJungle</span>  will have been defined. As methods
of the item, however, they have access to the item itself via <span class="codeWord">this</span>.
</p>

-->

</div>
</div>
</body>
</html>