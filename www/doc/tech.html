<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="description" content="Visibility and Persistence for JavaScript's Prototype Realm">
<title>PrototypeJungle</title>
<link rel="stylesheet" type="text/css"  href="/devstyle.css"> 
</head>
<body style="background-color:#eeeeee">


<div id="outerContainer>
  <div id="topbar">
     <div id="topbarOuter" style="padding-bottom:30px"><a href="/"><span class="mainTitle">PrototypeJungle</span></a>
        <img style ="position:relative;top:10px;border:none;left:-20px;" src="/images/logo.svg"  width="120" height="30"/>
        <div id = "topbarInner" style="position:relative;float:right;top:12px">           <a href="https://github.com/chrisGoad/prototypejungle/tree/firebase" class="ubutton">GitHub</a>
           <a href="/doc/tech.html">Docs</a>
           <a href="http://prototypejungle.org/doc/about.html" class="ubutton">About</a>
        </div>
        <div id ="worker" style="position:absolute;left:50px;top:4px">
           <iframe style="border-width:0px" id="workerIframe" width="1" height="1"></iframe>
        </div>
    </div>
  </div>
  <div id="innerContainer" style="background-color:#eeeeee">


<div style="text-align:center;font-size:14pt;top-padding:20px;color:black"><b>Technology</b></div>


<div class="tableOfContents"> 
    <div class="contentsLine"><a href="#prototypeTrees">1. Prototype Trees Defined</a></div>
     <div class="contentsLine"><a href="#instantiate">2. Instantiation</a></div>
    <div class="contentsLine"><a href="#serialize">3. Serialization</a></div>  
   <div class="contentsLine"><a href="#ammendment">4. An Ammendment</a></div>
        
</div>
<p>This document details the core technology.  
It covers internals which needn't be plumbed for most coding purposes. 
</p>

<div class="section" id="prototypeTrees">1. Prototype Trees Defined</div>
<!--
<p>   
There are two ways to go about providing an exact definition of the prototype tree structure:
 a concise graph-theoretical
definition, or a slower, but more intuitive definition that involves stepwise modification of the familiar notion of a JavaScript tree: the
kind that arises from <a href="http://www.json.org/">JSON</a>.
</p> <p>The quick definition: a prototype tree
  is a spanning tree over a Javascript object graph. Functions may appear in the tree, but only 
  as leaves. To be concrete, a node in the graph
  is a JavaScript object or primitive,
  and a directed edge runs from node A to B if there is a direct (not inherited)
  property P of A such A.P === B.
  The special property
  __parent,   picks out the spanning tree: B.__parent === A, with B.hasownProperty("__parent"), exactly when B is a child of A. Sequential, zero-based arrays are allowed as nodes too,
  and their elements are treated as children, and e.__parent === A when e is an element of array A.
  
  
  
<p>Now the slower way.</p>
-->

<p>Here again is a diagram of  a prototype tree: </p>

 <img src="../images/prototree.svg" style="bborder:thin black solid"  width="800" height="200"/>
<p style="margin-top:-80px">
Now the definition:</p>

<p>1) Start with  a JavaScript tree of 
the kind that is expressable in JSON, but allowing, unlike JSON, functions as leaves. Such a structure lacks prototypical inheritance, except from
the Javascript core items: Object.prototype, Function.prototype, and Array.prototype.<p>



<p>2) Next, allow prototype chains in the tree. This places another sort of graph over the first.
It has the same nodes as the original tree, but adds a new set of edges - 
 edges which join nodes A and B if
B is the prototype of A.  This second graph is  acyclic too, but is rarely connected. 
</p>
<p>
3) Add a special property __parent, where if there is a tree-edge from node A to node B, 
B.__parent === A.  There is a tree-edge from A to B  if the value of some own property P on A is B,
or if A is an array, and B is an element of A. As a convenience for coding, the special property __name is added too, such that whenever B.__parent === A,
and A.P === B with P an own property of A, B.__name === P</p>

<p>
4) Now that the __parent property explicitly picks out the tree, we can allow cross tree links. That is we allow A.P = B for any two nodes in
the tree. In practice, it is a surprising fact that this fourth generalization has rarely been needed in the development of applications.
</p>

<p>Prototype trees are also referred to as "items"</p>

<!--More specifically, for nodes
X and Y in T, if 
Object.getProtototypeOf(X) === Y, then let ypath be Y's path. Let X' be the node in T' at the same path as X. Then set X'.__prototype = ypath.
--><!--An example
of this  can be seen in the above serialization, where X is root.xx and Y is root.aProto. Note that the serialized node corresponding to this X has
"__prototype":"./aProto", that is, its __prototype is set to the path of Y. s-->
<div class="section" id="instantiate">2. Instantiation</div>

<p>In normal JavaScript usage, the instantiation of a prototype
(creation of a new object which inherits from the prototype)
is a one-level operation, implemented by <i>Object.create</i> or <i>new</i>. PrototypeJungle provides a method
for
instantiating an entire 
prototype tree T at one blow.</p>
<p>The algorithm is specified in detail below, but understanding this level of detail is  not required to make use of the operation
in coding; in practice, one might say, "it does the right thing".</p>

<p>Let <span class="codeWord">T</span>' = <span class="codeWord">T.instantiate()</span>. Then <span class="codeWord">T</span>' is a treewise copy of <span class="codeWord">T</span>, but initially (<a href="#lastStep">see below</a>) omits its atomic-valued properties, 
which <span class="codeWord">T</span>' will acquire by inheritance. <!-- (except in the
case described as the "last step" <a href="#lastStep">below</a>).--> <!--(By treewise-copy, I mean that with respect to the
labeled parent/child relation for internal nodes, <span class="codeWord">T</span> is isomorphic to <span class="codeWord">T</span>'.)-->  <span class="codeWord">T</span>' also has the same prototype structure as <span class="codeWord">T</span>, except that chains in <span class="codeWord">T</span>' are anchored back in <span class="codeWord">T</span>.
The exact situation is this: consider corresponding nodes <span class="codeWord">N</span> and <span class="codeWord">N</span>' in <span class="codeWord">T</span> and <span class="codeWord">T</span>', that is, nodes appearing at the same paths from the roots of <span class="codeWord">T</span> and <span class="codeWord">T</span>'.
Now consider the prototypes <span class="codeWord">P</span> and <span class="codeWord">P</span>' of <span class="codeWord">N</span> and <span class="codeWord">N</span>', that is, <span class="codeWord">P</span> and <span class="codeWord">P</span>' where
<span class="code">P=Object.getPrototypeOf(N)</span> and <span class="code">P'=Object.getPrototypeOf(N')</span>. There
are two cases. First, <span class="codeWord">P</span> might lie within <span class="codeWord">T</span>. Then <span class="codeWord">P</span>' is defined to be the corresponding node to <span class="codeWord">P</span>, treewise (ie the one at the same path). Second,
<span class="codeWord">P</span> might lie outside of the tree <span class="codeWord">T</span>.  Then <span class="codeWord">P</span>' is set to <span class="codeWord">N</span> itself. This is what I mean when I say that prototype chains in <span class="codeWord">T</span>' are anchored in <span class="codeWord">T</span>. If you follow
a prototype chain <span class="codeWord">C</span>' in <span class="codeWord">T</span>', it will pass through nodes at the same paths as those of the corresponding chain <span class="codeWord">C</span> in <span class="codeWord">T</span>,
as long as it is within the tree, but where it exits the tree, then it is 
anchored back over in <span class="codeWord">T</span> at the node in <span class="code">T</span> from which the exit node in
<span class="code">T</span>' was copied. </p>
<p id="lastStep">There is one more step in the algorithm. Consider again the case where
<span class="codeWord">P</span>, the prototype of <span class="codeWord">N</span>, lies within <span class="codeWord">T</span>.
Then <span class="codeWord">N</span>' will inherit from <span class="codeWord">P</span>', not <span class="codeWord">N</span>.
The direct atomic properties of <span class="codeWord">N</span> are copied to <span class="codeWord">N</span>', since
otherwise they would be, in a sense, lost.</p> 

<p>Here is a simple example. iii is the initial tree.
A red arrow a <span style="color:red;"><span style="font-size:10pt;position:relative;top:-1px">---</span><span style="position:relative;top:1px">&gt;</span></span>
b means that Object.getPrototypeOf(a)===b.</p>
<img src="/images/instantiate1.svg" style="border:none" width="200" height="140"/> 

<p>Then after,</p>
<pre><code>
jjj = iii.instantiate();
jjj.a.y = 4;
</code></pre>
<p>we have: </p> 
<img src="/images/instantiate2.svg" style="border:none" width="500" height="200"/>

<p>
So, eg,
jjj.b.x === 1,
since jjj.b inherits from jjj.a, which in turn inherits from iii.a. Note that jjj.b.z has been copied from iii.b.z, by the last-mentioned
<a href="#lastStep">step</a> of the algorithm mentioned above.</p>

<p><a href="https://github.com/chrisGoad/prototypejungle/blob/r3/www/js/core/instantiate.js">Here</a> is the implementation.</p>
 
 
<div class="section" id="serialize">3. Serialization</div> 

<p>Consider the following simple prototype tree, and let it be known as "root".</p>
<img src="/images/figure_serialize1.svg" style="border:none" width="500" height="200"/> 
  <!--
var root = pj.DNode.mk();
root.set("aProto",pj.DNode.mk());
root.aProto.set("pChild",pj.DNode.mk());
root.aProto.c = 111;
root.set("xx",root.aProto.instantiate()); 
root.xx.a = 123;
var repo = 'http://prototypejungle.org/sys/repo1';
var zz = root.xx.pChild;
zz.__isProtoChild();
zz.f = function (){};
yy = root.aProto.pChild;
yy.b = 777;
root.aProto.c = 111;
/*
var ss = pj.stringify(root,repo);
*/
var axis;
pj.install('http://prototypejungle.org/sys/repo1','chart/component/Axis1',function (err,rs) {
  console.log("done");
  axis = rs;
  debugger;
});

axis === pj.installedItems['http://prototypejungle.org/sys/repo1/chart/component/Axis1/item.js';
root.addRequire('ax
root.set("aa",axis.instantiate());

pj.stringify(root,repo);
</pre>
-->
<p>Then the serialization of this tree, prototypeJungle.stringify(root) is:</p>
<pre>
{"__prototype":"/Object",
 "aProto":{"__prototype":"/Object",
           "pChild":{"__prototype":"/Object",
                    "b":777},
           "c":111},
 "xx":{"__prototype":"./aProto",
       "pChild":{"__prototype":"..pc",
                 "f":"function () {}"}}
"__requires":[]}
);

</pre>

<p> When stored in an external file in the PrototypeJungle implementation,
the body of the serialization S is wrapped in "prototypeJungle.assertItemLoaded(S)".   assertItemLoaded 
 dispatches as appropriate to the deserialization algorithm.  assertItemLoaded thus follows the JSONP pattern, allowing serialized prototype trees
to be loaded from anywhere, without <a href="http://en.wikipedia.org/wiki/Cross-origin_resource_sharing">CORS</a>.  </p>
<p>The underlying form of the serialization is JSON. However there is special encoding for the links of  prototype chains,
and for functions.  Every object node in the tree has a unique path.  For example, the path of root.xx is "./xx"  of root.aProto.pChild is
"./aProto/pChild", and of root.aProto is "./aProto". These paths are used to designate the destinations of the prototype links that
will be rebuilt by deserialization.</p><p>The algorithm for serialization is as follows. Let T be the original tree,
and T' its deep-copy in which 
prototype links have been removed and  each function f has been replaced by {"__function":f.toString()}.  So,
T' has appropriate form for direct serialization in JSON. Now, the property __prototype  will be added to some nodes of T' to encode the prototype links.
Specifically, a __prototype property will be added to each node X' whose origin X in T has  a prototype Y in T. The value of __prototype is
set to the path of Y in T.
This allows the prototype link associated with 
X to be reconstructed during deserialization.</p>
<p>
This rule by itself would have been sufficient for serialization, but there  is a minor optimization.
Consider this situation: suppose that the prototype of X is Y, and X is a  node of a tree that came into being via the instantiation of an ancestor of Y.
Then to get from X to its prototype, just go to its parent, follow one link of prototype chain, and then descend again to the child with X's name. This
special path is designated "..pc" (parent-prototype-child).<!-- That is,
no path is needed to specify X's prototype. It is enough just to specify that it is an __instanceChild.-->
</p>  
<p> For basic nodes, which inherit directly from Object.prototype or Array.prototype, the __prototype property is set to the paths"/Object and "/Array" respectively.</p>
<p>Note how __prototype properties, including the case __prototype:"..pc", play  their roles in the above example.</p>

<p>As <a href="code.html#components">explained</a> in the coding guide, items can be built up from components that are held in separate files.
In a serialized item, a reference to an external component has the form </p>
<pre><code>
'[<i>repo</i>|<i>path</i>]'

(eg '[http://prototypejungle.org/sys/repo3|chart/bar1.js]')
</code></pre>

<p>or simply</p>
<pre><code>
'[path]'

(eg '[chart/bar1.js]')
</code></pre>

<p> In the PrototypeJungle implementation, URLs are expressed in the repo|path form to allow the organization of content
into repositories. Whenever an item X is loaded from an external source, its source is represented in this  repo|path form.
Then, when item X  refers in turn to other external items, it can do so by giving only the path, with the meaning that the
item is located at that path within X's own repo. This in turn allows easy cloning of whole repos.</p>

<p>

<p>Here are the implementations of <a href="https://github.com/chrisGoad/prototypejungle/blob/r3/www/js/core/externalize.js">serialization</a> and of
<a href="https://github.com/chrisGoad/prototypejungle/blob/r3/www/js/core/internalize.js">deserialization</a></p> 

<!--
<div class="section" id="components">4. The Component System</div> 
<p>Prototype trees can be represented as assemblies of components which are
stored separately. Information about external components is  held in the __requires property of a prototype tree. 
In serialized form, the value of the __requires structure for this
<a href="http://prototypejungle.org/chartsd?intro=1">bar chart</a> is
</p>

<pre><code>
  {"axis":{"repo":".","path":"chart/component/Axis1/item.js"},
   "marksPart":{"repo":".","path":"chart/marksPart/Bar1/item.js"}}
</code></pre>

<p>This causes the chart/compontent/Axis1/item.js prototype tree, and the chart/marksPart/Bar1/item.js tree to be loaded in advance of loading
the bar chart itself, and for these components to be instantiated and then  assigned to variables <code>axis</code>, and <code>marksPart</code>, respectively within the bar chart. 
This allows charts to be built using a common library components (axes, legends, etc.).
</p>
<p> The repo fields in the requires data structure were glossed over just now. Urls are split into a repo (repository) and path part to support repo-relative
addressing. The special repo value "." means  the repository from which this top level item was loaded. For example,
the bar chart was loaded from repository "http://prototypejungle.org/sys/repo2", so the above <code>requires</code> data
structure instructs that the axis component
be loaded from "http//prototypejungle.org/sys/repo2/chart/compontent/Axis1/item.js". (The repo field can be a URL, too, so that the
{repo:,path:} pair acts as an absolute web address.) If items are always built using repo-relative addressing within a given repo,
then the whole repo can be distributed to arbitrary web locations while preserving functionality.
</p>
<p> The component system is integrated into serialization in the  following way:
 Consider a component such as <code>axis</code> in the bar chart example.  This has as prototype a component A that has
been loaded from the external source http//prototypejungle.org/sys/repo2/chart/compontent/Axis1/item.js.
When serializing <code>axis</code> , recall that its __prototype field
should be set to the path of the prototype. But in this case, the path is not interior to the item being saved, but is relative to the __requires object. Such
requires/relative paths are written without an initial "./", in this case simply as "axis". <!--item.axis.TickP will also appear in the item (the prototype
for axis ticks). It's __prototype value is  "..pc", mea</p>
<p> A detail: note that the requires object is serialized without mention of prototypes (no __prototype fields, for example). This is because requires are
processed
in advance of the general deserialization, since the components mentioned need to be loaded before the serialization begins.  Thus on, the serialization side,
simple JSON will do for the requires.</p>
-->
<div class="section" id="ammendment">4. An Ammendment</div>

<p>Until now, one aspect of  the implementation  has been supressed for simplicity of exposition, but it is time to correct this.
Prototype trees as described so far
contain interior nodes which either inherit prototype-wise from elsewhere in the tree, from components, or are basic objects {}, or arrays [].
This was not quite right.  Instead of using plain object and arrays, we instead introduce prototypes:


<!--
These latter have as prototypes Object.prototype and Array.prototype, respectively.
One trouble with leaving things this way is that basic tree operations would need to be
defined on  Object.prototype and Array.prototype. This would constitute a polution of core JavaScript namespaces.
Instead, it is better to define our own prototypes for interior nodes of a prototype tree,
and define tree operations on those prototypes, leaving the core JavaScript namespaces alone. 
</p>
<p>This is easily done, via the definitions:
</p>
-->
<pre>
pj.Object = {}
pj.Array = [];
</pre>
<p>

To construct a new node for use in a prototype tree, the primitives
</p>
<pre>
pj.Object.mk = function () {return Object.create(pj.Object)}

pj.Array.mk = function () {return Object.create(pj.Array)}
</pre>
<p>
are defined. (Note that Object.create is used here, and not any form of <code>new</code>. This <code>new</code>-avoidance is a general PrototypeJungle policy, as explained
<a href="/devdoc/code.html#nonews">here</a>). This means that we can define tree operations on pj.Object and pj.Array without polluting the basic JavaScript name spaces Object.prototype and
Array.prototype. Such pollution would affect all JavaScript objects and arrays, not just the ones used in the PrototypeJungle implementation.
</p>
<p>

A final, and very useful, generalization can be made.  It was mentioned that for basic interior nodes, that is objects and arrays, in serialization, the __prototype property
was assigned "/Object" or "/Array", representing Object.prototype and Array.prototype, respectively.
This was mentioned as an ad-hoc rule covering these two cases. But, with our migration to pj.Object and pj.Array,
the rule loses its ad-hoc character, and gains wider applicability.  The general rule is this.</p>
<p>
The installation of the prototypeJungle code base, assigned to Window.pj, is itself a prototype tree. For any object Y in this tree, it is possible to use
Object.create(Y) as an interior node of a prototype tree that we are constructing. In serialization, Y is represented by its path within pj,
eg __prototype:"/Object" or __prototype:"/svg/tag/g". That is, prototype trees can be built over nodes derived by inheritance from arbitrary nodes in pj.
The general rule for paths is that "./path" indicates a path within the tree being serialized "/path"  a path in pj,
and "path" without initial decoration by "/" or "./",  a  component, that is a path within the requires.
</p>

<p>
This ammendment has no effect on the basic definitions. As always,
a prototype tree is
defined as a pair of graphs over the same set of nodes, graphs given by two sorts of edges: own-property-value edges, and isPrototypeOf edges.
The former graph, as always,
is restricted to be a tree.  Before the ammendment, interior nodes either inherited from another node in a tree,  or from Array.prototype or Object.prototype,
or from a component.
Now, interior nodes can inherit from any object in the PrototypeJungle installation as well.
</p>
<!--
repos that where items refer to components relative to their 
The rule for paths is this: "./path" is a path whose root is the prototype tree being serialized. Prototypes such as DNode and LNode appear within
the pj tree (the global object created by the PrototypeJungle installation). Paths which initiate from the root pj start with an initial "/", not "./"</p>

 <p> There is an implementation detail here. In the above definitions, interior nodes of the tree might take the form of
basic objects {}, and arrays [], which have as prototypes Object.prototype and Array.prototype respectively.
To avoid poluting these basic namespaces, we arrange in the implementation for   interior nodes to appear
at least one step of prototypical inheritance away from these primitives. The prototype for non-array object nodes is pj.Object, rather than
Object.prototype, and pj.Array rather than Array.prototype.
(initialialized via pj.Object = {} within the top level 
module pj) and for array nodes is pj.Array (initialized as pj.Array = []).  To generate new nodes: the operators
<pre>
pj.DNode.mk = function () {return Object.create(pj.DNode);}

pj.LNode.mk = function () {return Object.create(pj.LNode);}
</pre>
<p>
are defined.This avoids polluting the basic JavaScript name spaces with tree operators. This move is simple, and preserves all aspects of structure.
</p>    
-->
</div>
</div>
</body>
</html>