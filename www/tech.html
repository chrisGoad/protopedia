<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Prototype Jungle</title>
<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
<link rel="stylesheet" type="text/css"  href="/style.css"> 
</head>
<body style="background-color:#eeeeee">
<script src="/js/pj.js"></script>
<script src="/js/page.js"></script>

<script>

    
$('document').ready(function () {
    __pj__.page.genTopbar($('#topbar'),{includeTitle:1,toExclude:'tech'});
});


</script>

<div id="outerContainer"> 
  <div id="topbar"></div>

  
<div class="pageTitle">Technical Documentation</div>

<div>This document describes how to create  applications in Prototype Jungle - how to build structures with which the inspector/editor
can be used.   The intended audience is JavaScript programmers.</div>
<div class="section">1. Outline of the code base</div>

<p>The code base defines exactly
one global variable, __pj__.  Beneath __pj__ are the modules:</p>
<ul>
    <li>om - the object model</li>
        <li>geom - geometry</li>
    <li>draw - display geometrical objects using HTML5 canvas </li>
    <li>dom - DOM objects</li>
    <li>tree - display the hierarchies of JavaScript objects, and  prototype chains</li>
    <li>page - the inspect/edit web page</li>
</ul>

<p>Code files generally specialize in one module or another, but sometimes
add  to more than one module.</p>


<div class="section">2. Trees: om.LNode and om.DNode</div>


<p>In order to allow hierarchical browsing of  an application, a tree structure must be given to the part of the application which
will appear in the inspector. (Stated more precisely, a spanning tree is required, but references between nodes other than the parent-child edges are allowed).
The object model includes
prototypes <span class="codeWord">DNode</span> (dictionary node), and <span class="codeWord">LNode</span> (list node) for this purpose. These nodes differ in that their children are named by sequential integers
starting with zero in the <span class="codeWord">LNode</span> case, and by strings in the <span class="codeWord">DNode</span> case.  All internal nodes in a tree should be of type DNode or LNode (that is, inherit from the prototypes om.DNode,om.LNode).  Leaves may be atomic values (numbers,
strings,booleans, null, functions).
The primitives for building trees are introduced by example: </p>
<pre>
    
<code>
var om = __pj__.om;
var root = om.DNode.mk();
var aa = om.DNode.mk();
var bb = om.LNode.mk();

root.set("a",aa); // adds aa as a child named "a" of root
root.set("b",bb);

// introducing the basic operations name and parent:
bb.name();
==>b
bb.parent() == root;
==>true

// let's add some atomic data 
a.x = 5;  // set is not needed for atomic data 
a.f = function (x) {return x*x;}

// now for an LNode
var cc = om.LNode.mk();

cc.pushChild(c);
cc.pushChild(5);
cc.pushChild(d);

</code>
</pre>
<p>this yields:</p>
<pre><code>
          root
        /     \
       a       b
      /         \
     *        [c,5,d]
    / \
   x    y
  /      \
 5        6

</code>
</pre>


<p>
    

As indicated parenthetically above, there is nothing wrong with having properties of DNodes that reference
nodes in the tree  other than children,  as in </p>

<pre><code>
a.xx = b;
</code></pre>

<p>in the above example.Then xx is a cross-tree reference.</p>

<p> We will sometimes use the word "item" in what follows to refer to a DNode/LNode tree. </p>


<p><b>No news</b></p>
<p> Note that  nodes are constructed with <code>om.DNode.mk()</code> and om.LNode.mk(), rather than via the use of a "new". The definition of the mk method for DNode is:

<pre><code>

om.DNode.mk = function () {
  return Object.create(om.DNode);
}

</pre></code>

<p></p>Recall that Object.create(X) creates a new object with X as prototype (see this 
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create">documention</a>)
</p>


<p><span class="codeWord">DNode</span> itself is introduced simply with:</p>

<pre><code>
om.DNode = {};
</code></pre>

<p>and <span class="codeWord">LNode</span>  with:</p>


<pre><code>
om.LNode = [];
</code></pre>

<p>
That is to say, <span class="codeWord">om.DNode</span> itself serves as the prototype for instances.  In the more conventional pattern, <span class="codeWord">om.DNode</span> would be a function, and
the prototype property of that function, not DNode itself, would be the  prototype for the instances, via the new operator (note that if <code>X = function (){}, new X()</code> is equivalent
to <code>Object.create(X.prototype)</code>)
</p>
<p>
The <span class="codeWord">function, function.prototype, new</span> &nbsp; pattern has been in Javascipt all along, whereas the  more direct Object.create was introduced in recent years. Prototype Jungle
employs the newer pattern, not so much for its intrinsic  simplicity (though that's nice), but because this way of doing things has a major
simplifying effect on the entire Prototype Jungle code base. </p>

<p> You will never see a "new" anywhere in the code. The convention is that for prototype X, X.mk, is the creator/initializer (which may take arguments, of course).</p>


<div class="section">  instantiate</div>

The  DNode.instantiate method takes a tree T, and creates a new one T', with the same parent/child structure, but where each new node N' in T' has the corresponding
node N in T as its
prototype. That is, instantiate is the Javascript function Object.create, mapped over a tree. Simple as it is, this is the core operation of the
system, by which non-atomic structures are built from prototypes. Here is a simple code snippet, which takes a Rectangle, and builds another with the
same attributes, but red, rather than blue. </p>


<b>Update</b>

<p>Items are defined by computation as well as structure.  This is done by defining "update" methods which compute
the full state of an item.  When an item is displayed in the prototype jungle viewer or inspector, update methods
are run at load time, and each time there is a change. Specifically, to update a item, a depth first traversal
of the tree is done with the rule: when an update method is present for the current node, execute it.  Traversal terminates
at the point where update methods are found. </p>

<p> Here is an example:</p>




<pre><code>

(function () {
  var examples = __pj__.setIfMissing("examples");
  var geom = __pj__.geom;
  var om = __pj__.om;
  var Nested = examples.set("Nested",om.DNode.mk());
  Nested.namedType();
  // The arc prototype
  var arcP =Nested.set("arcP",
              geom.Arc.mk({radius:100,startAngle:0,endAngle:2*Math.PI}));
  arcP.hide();
  Nested.radiusFactor = 0.9;
  Nested.count = 10;
  
  Nested.update = function () {
    var arcs = om.LNode.mk().computed();
    this.set("arcs",arcs);
    var crad = this.arcP.radius;
    var cnt = this.count;
    for (var i=0;i&lt;this.count;i++) {
      var ca = this.arcP.instantiate();
      ca.show();
      arcs.pushChild(ca);
      ca.setf("radius",crad);  // freeze the radius
      crad = crad * this.radiusFactor;
    }
  };
  om.save(Nested);
})();
  

</code></pre>



<p>This yields  <a href="http://s3.prototypejungle.org/item/14/icdgioslwf">http://s3.prototypejungle.org/item/14/icdgioslwf</a>
via the <a href="/build.html">build</a> process.</p>
To inspect, see: <a href="http://dev.prototypejungle.org/inspect?item=http://s3.prototypejungle.org/item/14/icdgioslwf">
http://dev.prototypejungle.org/inspect?item=http://s3.prototypejungle.org/item/14/icdgioslwf
</a> </p>

<p>Three lines need explanation:</p>

<pre><code>
  Nested.namedType();
</code></pre>
<p>This has a minor effect: an item x will be displayed as x:Nested  in the inspector if Nested is the
first object flagged as a named type in its prototype
chain. There is nothing otherwise special about named types; any item can be flagged as such, affecting only display.
</p>


<pre><code>
    var arcs = om.LNode.mk().computed();
</code></pre>

<p>When an item is declared <b>computed</b>, it is removed before saving, with the assumption that
it will be recomputed by an update on reloading. To check in the inspector on what's computed, choose "manual update" in "options", then click the "remove computed" button.</p>



<pre><code>
      ca.setf("radius",crad);  // freeze the radius
</code></pre>

<p>Normally, all atomic properties are editable in the inspector.  The "setf" method, however, declares
that the property in question should be "frozen", that is, closed from modification in the inspector.
Only the inspector is affected, the property is not modified at the deeper JavaScript level (its 
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">
descriptor</a> is not modified).

</p>


<subsection>Retention of modifications to computed content</subsection>
<p>Computed content can be modified in the inspector,  and these modifications will be retained through subsequent
updates, saves, and restores. The implementation keeps track of modifications, 
and, whenever an update is done, reapplies the modifications to the updated state.  </p>


<b>Saving and restoring items</b>
<p>The last section implicitly introduced the fact that items can be saved and restored
 with their prototype structures and functions  intact. But there is one more aspect of this process
 that needs mention: one file can reference items from others, often using them as prototypes.
The prototype chain for an item might have elements from several separate
files. Here is an example:</p>


<pre><code>

__pj__.om.restore(["http://s3.prototypejungle.org/item/13/iofvnynbuw"],
    function () {
      var examples = __pj__.examples;
      var  tna = examples.set("TwoNestedArcs",om.DNode.mk());
      
      var n1 = tna.set("n1",examples.Nested.instantiate());
      tna.set("n2",examples.Nested.instantiate());
      
      // adjust some parameters
      n1.arcP.radius = 30;
      n1.arcP.style.strokeStyle = "red";
      om.save(top);
    }
  );

  </pre></code>


<p> Recall that 
http://s3.prototypejungle.org/item/13/iofvnynbuw contains the definition of the prototype Nested which
appears in the last section. Here the restore operation loads that definition in, prior to defining
a simple structure in which Nested is instantiated. The details:

<pre><code>
om.restore([&lt;file0>,&lt;file1>...&lt;/filen>],fn);
</code></pre>

<p></p>
restores the indicated files in order, and when it is done, calls the function fn.
fn might take one
argument, and, if so, fn is called with an array consisting of the items restored from the files [&lt;file0>,&lt;file1>...</filen>].
Often, though, as in this example, the purpose of restoring files is to populate the __pj__ tree with  particular
items, and fn takes no arguments.</p>


<p>The TwoNestedArcs structure is saved in </p>


<p>The save process notices when parts of what it is saving come from other files,
and mentions them by reference in the saved structure.  This usually involves splitting up prototype chains; earlier parts of the chain
might come from one place, and later elements from another (an arbitrary number of  sources might be involved).
For example TwoNestedArcs.n1, as saved, has five elements in its prototype chain: n1 itself, Nested, DNode, {} (the vanilla
object built in om.js to be the prototype of DNode), and <a https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/prototype>Object.prototype</a>,
the <a href="http://en.wikipedia.org/wiki/Eve">mother</a> of all JavaScript objects.
The first four are defined in the files: XX, YY,om.js, and om.js respectively. The last of course is already present
when any JavaScript enviroment starts up.</p>

<p>A more extensive and realistic example of building up prototype chains from a series of saved items can be found
in the <a href="https://github.com/chrisGoad/prototypejungle/tree/master/www/gen/chart">chart</a> example.</p>

<section>Build</section>
The <a href="/build.html">build</a>  page allows items to be built from source code appearing at any URL.
It places the item which it builds in PrototypeJungle's S3 bucket, http://s3.prototypejungle.org, under
an autogenerated path.  This  allows  the system to be used by anyone - no registration or log in required.
But there are drawbacks to the autonaming scheme. It is in my near-term development plans
to add user registration and login, and user controlled hierarchical naming of files created by the
build process.</p>




</div>
</body>
</html>