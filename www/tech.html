<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Prototype Jungle</title>
<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<link rel="stylesheet" type="text/css"  href="/style.css"> 
</head>
<body style="background-color:#eeeeee">
<script src="/js/pj.js"></script>
<script src="/js/util.js"></script>
<script src="/js/page.js"></script>

<script>

    
$('document').ready(function () {
    
    var om = __pj__.om;
    om.checkSession(function (rs) {
        __pj__.page.genTopbar($('#topbar'),{includeTitle:1,toExclude:'tech'});
        $('#openTreeDetails').click(function () {
            $('#treeDetails').show();
        });
         $('#closeTreeDetails').click(function () {
            $('#treeDetails').hide();
        });
           $('#openInstantiateDetails').click(function () {
            $('#instantiateDetails').show();
        });
         $('#closeInstantiateDetails').click(function () {
            $('#instantiateDetails').hide();
        });
    });
});



</script>

<div id="outerContainer"> 
  <div id="topbar"></div>

  
<div class="pageTitle">Technical Documentation</div>

<div class="tableOfContents">
  <div class="contentsLine"><a href="#outline">1. Outline of the code base</a></div>
  <div class="contentsLine"><a href="#trees">2. Trees</a></div>
  <div class="contentsLine"><a href="#nonews">3. No news</a></div>
  <div class="contentsLine"><a href="#instantiate">4. Instantiate</a></div>
  <div class="contentsLine"><a href="#update">5. Update</a></div>
  <div class="contentsLine"><a href="#retention">6. Retention of modifications to computed content</a></div>
  <div class="contentsLine"><a href="#save">7. Saving and restoring items</a></div>
  <div class="contentsLine"><a href="#build">8. Build</a></div>
  <div class="contentsLine"><a href="#sourceCode">9. Managing source code</a></div>
  <div class="contentsLine"><a href="#autofit">10. Autofit for display</a></div>
  <div class="contentsLine"><a href="#other">11. Other applications</a></div> 
</div>

<div>This document describes how to create  applications in Prototype Jungle - how to build structures with which the inspector/editor
can be used.   The intended audience is JavaScript programmers.</div>
<div class="section" id="outline">1. Outline of the code base</div>

<p>The code base defines exactly
one global variable, __pj__.  Beneath __pj__ are the modules:</p>
<ul>
    <li>om - the object model</li>
        <li>geom - geometry</li>
    <li>draw - display geometrical objects using HTML5 canvas </li>
    <li>dom - DOM objects</li>
    <li>tree - display the hierarchies of JavaScript objects, and  prototype chains</li>
    <li>page - the web page being built</li>
</ul>

<p>Code files generally specialize in one module or another, but sometimes
add  to more than one module.</p>


<div class="section" id="trees">2. Trees</div>

<p>In order to support hierarchical browsing and saving of  an application, the application should be structured as a tree.
(Stated more precisely, a spanning tree is required, but references between nodes other than the parent-child edges are allowed).
The object model includes
prototypes <span class="codeWord">om.DNode</span> (dictionary node), and <span class="codeWord">om.LNode</span> (list node) for this purpose. These nodes differ in that their children are named by sequential integers
starting with zero in the <span class="codeWord">LNode</span> case, and by strings in the <span class="codeWord">DNode</span> case.  All internal nodes in a tree should be of type DNode or LNode (that is, inherit from the prototypes om.DNode,om.LNode).  Leaves may be atomic values (numbers,
strings,booleans, null, functions).</p>

<div class="clickable" id="openTreeDetails">Coding details for trees</div>
<div id="treeDetails" class="techDetails">
<div class="close" id="closeTreeDetails">X</div>

<p style="padding-top:20px">Tree primitives: </p>
<pre><code>
om.DNode.mk();
</code></pre>

<p> creates a  new <span class="codeWord">DNode</span>, and</p>
<pre><code>
om.LNode.mk();
</code></pre>
<p> a new <span class="codeWord">LNode</span>.</p>
<pre><code>
dpr.set(nm,ch);
</code></pre>

<p>Assigns  <span class="codeWord">ch</span> as the child named <span class="codeWord">nm</span> of <span class="codeWord">pr</span> (a <span class="codeWord">DNode</span>).
Then <span class="code">ch.parent() == dpr, ch.name() == nm, and pr[nm] == ch</span> (child selection on <span class="codeWord">DNodes</span> is ordinary property selection)
</p>

<pre><code>
lpr.pushChild(ch);
</code></pre>

<p>Pushes <span class="codeWord">ch</span> onto the end of the <span class="codeWord">LNode</span> <span class="codeWord">lpr</span>,
and assigns <span class="codeWord">lpr</span> as the parent of <span class="codeWord">ch</span>. Then, <span class="code">lpr[lpr.length-1] == ch,
ch.name() == lpr.length-1, and ch.parent() == lpr</span>.
</p>
<p>
Here is a quick example:
</p>

<pre><code>
var om = __pj__.om;
var root = om.DNode.mk();
var aa = om.DNode.mk();
var bb = om.LNode.mk();

root.set("a",aa); // adds aa as a child named "a" of root
root.set("b",bb);

// introducing the basic operations name and parent:
bb.name();
==>b
bb.parent() == root;
==>true

// let's add some atomic data 
aa.x = 5;  // set is not needed for atomic data 
aa.f = function (x) {return x*x;}

// now for an LNode
var cc = om.LNode.mk();

cc.pushChild(om.DNode.mk().set("z",45));
cc.pushChild(5);

</code>
</pre>
<p>this yields:</p>
<pre><code>
          --root--
        /          \
       a            b
      /              \
     *              [ *, 5]
    / \              /
   x    f           z
  /      \         /
 5    function    45

</code>
</pre>
<p> where * is a DNode</p>

<p>
This could also be built with
</p>

<pre><code>
var root = om.lift({a:{x:5},b:[{z:45,5]})
root.a.f = function (x) {return x*x};
</code></pre>

<p>lift applies to "ordinary" JavaScript trees of the kind directly representable in the object notation.</p>
    

<p>As indicated parenthetically above, there is nothing wrong with having properties of DNodes that reference
nodes in the tree  other than children,  as in </p>

<pre><code>
a.xx = b;
</code></pre>

<p>in the above example.Then xx is a cross-tree reference.</p>
<p><i>Restriction on names</i>: names may include only letters, numerals, and the underbar, and may not start with a numeral.</p>
</div>
<p> We will sometimes use the word "item" in what follows to refer to a DNode/LNode tree. </p>


<div class="section" id="nonews">3. No news</div>
<p> Nodes are constructed with <code>om.DNode.mk()</code> and om.LNode.mk(), rather than via the use of a "new". The definition of the mk method for DNode is:

<pre><code>
om.DNode.mk = function () {
  return Object.create(om.DNode);
}
</code></pre>


<p>Recall that <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create">Object.create</a>(X) creates a new object with X as prototype.
</p>


<p><span class="codeWord">DNode</span> itself is introduced simply with:</p>

<pre><code>
om.DNode = {};
</code></pre>

<p>and <span class="codeWord">LNode</span>  with:</p>


<pre><code>
om.LNode = [];
</code></pre>

<p>
That is to say, <span class="codeWord">om.DNode</span> itself serves as the prototype for instances.  In the more conventional pattern, <span class="codeWord">om.DNode</span> would be a function, and
the prototype property of that function, not DNode itself, would be the  prototype for the instances, via the new operator (note that if <code>X = function (){}, new X()</code> is equivalent
to <code>Object.create(X.prototype)</code>)
</p>
<p>
The <span class="codeWord"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new">
function, function.prototype, new</a></span> &nbsp; pattern has been in Javascipt all along, whereas the  more direct <span class="codeWord">Object.create</span> was introduced in recent years, in version 1.8.5. Prototype Jungle
employs the newer pattern, not so much for its intrinsic  simplicity (though that's nice), but because this way of doing things has a major
simplifying effect on the entire Prototype Jungle code base. </p>

<p> You will never see a "new" anywhere in the code. The convention is that for prototype  <span class="codeWord">X</span>, <span class="codeWord">X.mk</span> is the creator/initializer (which may take arguments, of course).</p>


<div class="section" id="instantiate">4. Instantiate</div>

<p>
A core operation in the system is instantiation of items, that is to say, trees, implemented by
<span class="codeWord">om.DNode.instantiate</span> and <span class="codeWord">om.LNode.instantiate</span>.
It is the analog of <span class="codeWord">Object.create</span>,  but applied to a tree
of arbitrary depth rather than a single object.
It creates a new tree, with the same tree and prototype structure as the old one,
but which inherits from the old tree as appropriate. 
</p>

<p>The <span class="clickable" id="openInstantiateDetails">details</span> are a little complicated, but it is the kind of complexity that you don't need to worry about unless you're curious.
Instantiation "does the right thing".</p>

<div id="instantiateDetails" class="techDetails">
<div class="close" id="closeInstantiateDetails">X</div>

<p>Let <span class="codeWord">T</span>' be the instantiation of tree <span class="codeWord">T</span>. Then <span class="codeWord">T</span>' is a treewise copy of <span class="codeWord">T</span>. That is, considering the
labeled parent/child relation, <span class="codeWord">T</span> is isomorphic to <span class="codeWord">T</span>', and has the same atomic values at leaves. <span class="codeWord">T</span>' also has the same prototype structure as <span class="codeWord">T</span>, except that chains in <span class="codeWord">T</span>' are anchored back in <span class="codeWord">T</span>.
The exact situation is this: consider corresponding nodes <span class="codeWord">N</span> and <span class="codeWord">N</span>' in <span class="codeWord">T</span> and <span class="codeWord">T</span>', that is, nodes appearing at the same paths from the roots of <span class="codeWord">T</span> and <span class="codeWord">T</span>'.
Now consider the prototypes <span class="codeWord">P</span> and <span class="codeWord">P</span>' of <span class="codeWord">N</span> and <span class="codeWord">N</span>', that is, <span class="codeWord">P</span> and <span class="codeWord">P</span>' where
<span class="code">P=Object.getPrototypeOf(N)</span> and <span class="code">P'=Object.getPrototypeOf(N')</span>. There
are two cases. First, <span class="codeWord">P</span> might lie within <span class="codeWord">T</span>. Then <span class="codeWord">P</span>' is defined to be the corresponding node to <span class="codeWord">P</span>, treewise (ie the one at the same path). Second,
<span class="codeWord">P</span> might lie outside of the tree <span class="codeWord">T</span>.  Then <span class="codeWord">P</span>' is set to <span class="codeWord">N</span> itself. This is what I mean when I say that prototype chains in <span class="codeWord">T</span>' are anchored in <span class="codeWord">T</span>. If you follow
a prototype chain <span class="codeWord">C</span>' in <span class="codeWord">T</span>', it will pass through nodes at the same paths as those of the corresponding chain <span class="codeWord">C</span> in <span class="codeWord">T</span>,
as long as it is within the tree, but where it exits the tree, then it is 
anchored back over in <span class="codeWord">T</span>.</p>
<p><a href="https://prototypejungle.org/js/instantiate.js">Here</a> is the implementation.</p>
</div>

<div class="section" id="update">5. Update</div>

<p>Items are defined by computation as well as structure.  This is done by defining "update" methods which compute
the full state of an item.  When an item is displayed in the Prototype Jungle viewer or inspector, update methods
are run at load time, and each time there is a change. Specifically, to update a item, a depth first traversal
of the tree is done with the rule: when an update method is present for the current node, execute it.  Traversal terminates
at the point where update methods are found. </p>

<p> Here is an example:</p>




<pre><code>

(function () {
  var examples = __pj__.setIfMissing("examples");
  var geom = __pj__.geom;
  var om = __pj__.om;
  var Nested = examples.set("Nested",geom.Shape.mk());
  Nested.namedType();
  // The arc prototype
  var arcP =Nested.set("arcP",
              geom.Arc.mk({radius:100,startAngle:0,endAngle:2*Math.PI}));
  arcP.hide();
  Nested.radiusFactor = 0.9;
  Nested.count = 10;
  
  Nested.update = function () {
    var arcs = om.LNode.mk().computed();
    this.set("arcs",arcs);
    var crad = this.arcP.radius;
    var cnt = this.count;
    for (var i=0;i&lt;this.count;i++) {
      var ca = this.arcP.instantiate();
      ca.show();
      arcs.pushChild(ca);
      ca.setf("radius",crad);  // freeze the radius
      crad = crad * this.radiusFactor;
    }
  };
  om.save(Nested);
})();
  

</code></pre>



<p>This yields  <a href="http://s3.prototypejungle.org/pj/repo0/examples/Nested">http://s3.prototypejungle.org/pj/repo0/examples/Nested</a>
via the <a href="#build">build</a> process.</p>
<p>
To inspect, see: <a href="http://prototypejungle.org/inspect?item=http://s3.prototypejungle.org/pj/repo0/examples/Nested">
http://s3.prototypejungle.org/pj/repo0/examples/Nested
</a> </p>

<p>Four lines need explanation:</p>



<pre><code>
  var Nested = examples.set("Nested",geom.Shape.mk());
</code></pre>
<p><span class="codeWord">geom.Shape</span> is the prototype for all displayable objects, and itself inherits from <span class="codeWord">DNode</span>. <span class="codeWord">geom.Shape.mk()</span>
constructs an empty container to which other shapes can be added.
</p>

<pre><code>
  Nested.namedType();
</code></pre>
<p>This has a minor effect: an item <span class="codeWord">x</span> will be displayed as <span class="codeWord">x:Nested</span>  in the inspector if <span class="codeWord">Nested</span> is the
first object flagged as a named type in its prototype
chain. There is nothing otherwise special about named types; any item can be flagged as such, affecting only display.
</p>


<pre><code>
    var arcs = om.LNode.mk().computed();
</code></pre>

<p>When an item is declared <span class="codeWord">computed</span>, it is removed before saving, with the assumption that
it will be recomputed by an update on reloading. To check in the inspector on what's computed, choose "manual update" in "options", then click the "remove computed" button.</p>



<pre><code>
      ca.setf("radius",crad);  // freeze the radius
</code></pre>

<p>Normally, all atomic properties are editable in the inspector.  The <span class="codeWord">setf</span> method, however, declares
that the property in question should be "frozen", that is, closed from modification in the inspector.
Only the inspector is affected, the property is not modified at the deeper JavaScript level (its 
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">
descriptor</a> is not modified).

</p>


<div class="section" id="retention">6. Retention of modifications to computed content</div>
<p>Computed content can be modified in the inspector,  and these modifications will be retained through subsequent
updates, saves, and restores. The implementation keeps track of modifications, 
and, whenever an update is done, reapplies the modifications to the updated state.  </p>


<div class="section" id="save">7. Saving and restoring items</div>
<p>The last section implicitly introduced the fact that items can be saved and restored
 with their prototype structures and functions  intact. But there is one more aspect of this process
 that needs mention: one file can reference items from others, often using them as prototypes.
The prototype chain for an item might have elements from several separate
files. Here is an example:</p>


<pre><code>
__pj__.om.restore(["http://s3.prototypejungle.org/pj/repo0/examples/Nested"],
    function (na) {
      var examples = __pj__.examples;
      var top = examples.set("twoNestedArcs",geom.Shape.mk());
      
      var n1  = top.set("n1",examples.Nested.instantiate());
      var n2  = top.set("n2",examples.Nested.instantiate());
      
      // adjust some parameters
      n2.arcP.radius = 30;
      n2.arcP.style.strokeStyle = "red";
      om.save(top);
    }
  );
</code></pre>



<p> Recall that 
<span class="codeWord">http://s3.prototypejungle.org/pj/repo0/examples/Nested</span> contains the definition of the prototype <span class="codeWord">Nested</span> which
appears in the last section. Here the restore operation loads that definition in, prior to defining
a simple structure in which <span class="codeWord">Nested</span> is instantiated. The details:

<pre><code>
om.restore([&lt;file0>,&lt;file1>...&lt;/filen>],fn);
</code></pre>

<p>
restores the indicated files in order, and when it is done, calls the function <span class="codeWord">fn</span>.
<span class="codeWord">fn</span> might take one
argument, and, if so, <span class="codeWord">fn</span> is called with an array consisting of the items restored from the files <span class="codeWord">[&lt;file0&gt;,&lt;file1&gt;...&lt;/filen&gt;]</span>.
Often, though, as in this example, the purpose of restoring files is to populate the __pj__ tree with  particular
items, and <span class="codeWord">fn</span> takes no arguments.</p>


<p>The TwoNestedArcs structure is saved in
<a href="http://s3.prototypejungle.org/pj/repo0/examples/twoNestedArcs">http://s3.prototypejungle.org/pj/repo0/examples/twoNestedArcs</a></p>


<p>The save process notices when parts of what it is saving come from other files,
and mentions them by reference in the saved structure.  This usually involves splitting up prototype chains; earlier parts of the chain
might come from one place, and later elements from another (an arbitrary number of  sources might be involved).
For example <span class="codeWord">TwoNestedArcs.n1</span>, as saved, has six elements in its prototype chain: <span class="codeWord">n1</span> itself,
<span class="codeWord">Nested</span>, <span class="codeWord">Shape</span>,<span class="codeWord">DNode</span>, <span class="codeWord">{}</span> (the vanilla
object built in om.js to be the prototype of <span class="codeWord">DNode</span>), and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/prototype">Object.prototype</a>,
the <a href="http://en.wikipedia.org/wiki/Eve">mother</a> of all JavaScript objects.
The first four are defined in the files: <a href="http://prototypejungle.org/gen/examples/twoNestedArcs.js">twoNestedArcs.js</a>,
<a href="http://prototypejungle.org/gen/examples/nested.js">nested.js</a>, <a href="http://prototypejungle.org/js/om.js">om.js</a>, and
<a href="http://prototypejungle.org/js/om.js">om.js</a> respectively. </p>

<p>A more extensive and realistic example of building up prototype chains from a series of saved items can be found
in the <a href="https://github.com/chrisGoad/prototypejungle/tree/master/www/gen/chart">chart</a> example.</p>


<div class="section" id="build">8. Build</div>
The <a href="/build.html">build</a>  page allows items to be built from source code appearing at any URL.
It places the item which it builds in  PrototypeJungle's S3 bucket, at http://s3.prototypejungle.org/<i>handle/prefix/path</i>. Explanations:

<p><i>handle</i>: When you first sign in at prototype jungle, you are asked to specify a handle, a string which is unique to you among users. </p>

<p><i>path</i>. Each build operation adds items to the __pj__ tree.  Consider the <span class="codeWord">Nested</span> example, which includes these lines:</p>

<pre><code>
  var examples = __pj__.setIfMissing("examples");
  var Nested = examples.set("Nested",geom.Shape.mk());
</code></pre>

 <p> and at the end of the build:</p>
  
  <pre><code>
  save(Nested)
  </code></pre>


  <span class="codeWord">Nested</span> is the root of the tree which is built, and the item which is saved at the end. The path of this root in this case is "/examples/Nested".
  When <span class="codeWord">Nested</span> is saved, the external URL ends with this same path.
  
<p><i>prefix</i>: The prefix is a way of organizing your work in such a way that paths in separate applications avoid trampling on each other. The
prefix is chosen when the build is done. </p>

<div class="section" id="sourceCode">9. Managing source code</div>

<p>At some future date, Prototype Jungle will include facilities for managing source code, but for the moment, you will need to manage source
code separately. There is an excellent option for this: <a href="https://github.com">GitHub</a>. If you are accustomed to working with GitHub, nothing more needs be said:
you can work with code as you usually do; just use the GitHub URLs of source files with Prototype Jungle when doing builds.
If not, sign up at GitHub, create a repository, and add and edit files. You don't need to get involved in the Git aspects at all if you
don't want; you can just treat GitHub as a spot to create and edit web-accessible files. For quick expermiments, there a there are many
alternatives, for example <a href="http://pastebin.com">Pastebin</a>, and <a href="http://dropbox.com">Dropbox</a>. With Pastebin, you need not even register to create files with URls.</p>

<div class="section" id="autofit">10. Autofit for display</div>

<p>When an item is displayed on the canvas, the top level transformation is automatically adjusted in such a way
that the item fits evenly  within the canvas, under the condition that the item lies within coordinates -1000 and 1000 in x and y.
</p>

<div class="section" id="other">11. Other applications</div>

<p>The initial application area of Prototype Jungle is 2d graphics, but only a little of the code is associated with that particular application.
The capabilities of  browsing, editing, and saving  underlying prototype structures  are  application independent. To choose a random example,
music makes a lot of sense as an application:  what is an instrument, but an element of  a prototype chain originating with Note and terminating in a particular
played sound?
</p>




</div>
</body>
</html>