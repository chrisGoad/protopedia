<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Prototype Jungle</title>
<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
<link rel="stylesheet" type="text/css"  href="/style.css"> 
</head>
<body style="background-color:#eeeeee">
<script src="/js/page.js"></script>

<script>

    
$('document').ready(function () {
    __pj__.genTopbar($('#topbar'),1,'tech');
});


</script>

<div id="outerContainer"> 
  <div id="topbar"></div>

<div class="pageTitle">Technical Documentation</div>
<div class="section">1. Outline of the code base</div>

<p>The code base defines exactly
one global variable, __pj__.  Beneath __pj__ are the modules:</p>
<ul>
    <li>om - the object model</li>
        <li>geom - geometry</li>
    <li>draw - display geometrical objects using HTML5 canvas </li>
    <li>dom - DOM objects</li>
    <li>tree - display the hierarchies of JavaScript objects, and the prototype chains</li>
    <li>page - build the inspect/edit web page</li>
</ul>

<p>Code files generally specialize in one module or another, but sometimes
add  to more than one module.</p>


<div class="section">2. om </div>

<p>In order to allow hierarchical browsing of  an application, a tree structure must be given to the part of the application which
will appear in the inspector. The object model includes
prototypes <span class="codeWord">DNode</span> (dictionary node), and <span class="codeWord">LNode</span> (list node) for this purpose. These nodes differ in that their children are named by sequential integers
starting with zero in the <span class="codeWord">LNode</span> case, and by strings in the <span class="codeWord">DNode</span> case.  All internal nodes in a tree should be of type DNode or LNode (that is, inherit from the prototypes om.DNode,om.LNode).  Leaves may be atomic values (numbers,
strings,booleans, null, functions).
The primitives for building trees are introduced by example: </p>
<pre>
    
<code>
var om = __pj__.om;
var root = om.DNode.mk();
var aa = om.DNode.mk();
var bb = om.LNode.mk();

root.set("a",aa); // adds aa as a child named "a" of root
root.set("b",bb);

// introducing the basic operations name and parent:
bb.name();
==>b
bb.parent() == root;
==>true

// let's add some atomic data 
a.x = 5;  // set is not needed for atomic data 
a.f = function (x) {return x*x;}

// now for an LNode
var cc = om.LNode.mk();

cc.pushChild(c);
cc.pushChild(5);
cc.pushChild(d);

</code>
</pre>
<p>this yields:</p>
<pre><code>
          root
        /     \
       a       b
      /         \
     *        [c,5,d]
    / \
   x    y
  /      \
 5        6

</code>
</pre>


<p>

There is nothing wrong with having properties of DNodes that reference
nodes in the tree  other than children,  as in </p>

<pre><code>
a.xx = b;
</code></pre>

<p>in the above example.Then xx is a kind of cross-tree link.</p>

<p><b>No news</b></p>
<p> Note that  nodes are constructed with <code>om.DNode.mk()</code> and om.LNode.mk(), rather than via the use of a "new". The definition of the mk method for DNode is:

<pre><code>

om.DNode.mk = function () {
  return Object.create(om.DNode);
}

</pre></code>

<p></p>Recall that Object.create(X) creates a new object with X as prototype (see this 
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create">documention</a>)
</p>


<p><span class="codeWord">DNode</span> itself is introduced simply with:</p>

<pre><code>
om.DNode = {};
</code></pre>

<p>and <span class="codeWord">LNode</span>  with:</p>


<pre><code>
om.LNode = [];
</code></pre>

<p>
That is to say, <span class="codeWord">om.DNode</span> itself serves as the prototype for instances.  In the more conventional pattern, <span class="codeWord">om.DNode</span> would be a function, and
the prototype property of that function, not DNode itself, would be the  prototype for the instances, via the new operator (note that if <code>X = function (){}, new X()</code> is equivalent
to <code>Object.create(X.prototype)</code>)
</p>
<p>
The <span class="codeWord">function, function.prototype, new</span> &nbsp; pattern has been in Javascipt all along, whereas the  more direct Object.create was introduced in recent years. Prototype Jungle
employs the newer pattern, not so much for its intrinsic  simplicity (though that's nice), but because this way of doing things has a major
simplifying effect on the entire Prototype Jungle code base. </p>

<p> You will never see a "new" anywhere in the code. The convention is that for prototype X, X.mk, is the initializer (which may take arguments, of course).</p>


<div class="section">  instantiate</div>

The  DNode.instantiate method takes a tree T, and creates a new one T', with the same parent/child structure, but where each new node N' in T' has the corresponding
node N in T as its
prototype. That is, instantiate is the Javascript function Object.create, mapped over a tree. Simple as it is, this is the core operation of the
system, by which non-atomic structures are built from prototypes. Here is a simple code snippet, which takes a Rectangle, and builds another with the
same attributes, but red, rather than blue. </p>


<b>externalize</b>
<p>
Objects can be saved externally,  with their prototype structures and functions  intact.  One file can reference prototypes from others. 
The prototype chain for an application object might have elements from several separate
files. This is the analog for prototypes of class libraries. </p>

<p> Here are the specifics, again introduced by example.</p>

<p>Suppose the contents of F are </p>


the latter
Libraries of
prototypes can be built for reuse in 
a file,  information about its origin is retained. If new objects are instantiated from prototypes from file F,   and the new objects are
in turn stored externally in F', F' will record the prototype links back into F as external references, without copying. In this manner libraries of
prototypes can be built for use in varied circumstances.  
</p>




</div>
</body>
</html>