<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PrototypeJungle</title>
<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<link rel="stylesheet" type="text/css"  href="/style.css"> 
</head>
<body style="background-color:#eeeeee">
<script src="/min/min.js"></script>

<script>

    
$('document').ready(function () {
    var __pj__ = prototypeJungle;
    var om = __pj__.om;
    om.checkSession(function (rs) {
        __pj__.page.genTopbar($('#topbar'),{includeTitle:1,toExclude:{'tech':1}});
        $('#openTreeDetails').click(function () {
            $('#treeDetails').show();
        });
         $('#closeTreeDetails').click(function () {
            $('#treeDetails').hide();
        });
           $('#openInstantiateDetails').click(function () {
            $('#instantiateDetails').show();
        });
         $('#closeInstantiateDetails').click(function () {
            $('#instantiateDetails').hide();
        });
    });
});



</script>

<div id="outerContainer"> 
  <div id="topbar">
     <div id="topbarOuter" style="padding-bottom:30px"><span class="mainTitle">PrototypeJungle</span>
        <div id = "topbarInner" style="float:right"></div>
    </div>
  </div>

  
<div class="pageTitle">Technical Documentation</div>

<div class="tableOfContents">
  <div class="contentsLine"><a href="#status">1. Status</a></div>
  <div class="contentsLine"><a href="#quickStart">2. Quick start </a></div>
  <div class="contentsLine"><a href="#overview">3. Overview </a></div>
  <div class="contentsLine"><a href="#outline">4. Outline of the code base</a></div>
  <div class="contentsLine"><a href="#trees">5. Trees</a></div>
  <div class="contentsLine"><a href="#urls">6. URLs for items</a></div>
    <div class="contentsLine"><a href="#nonews">7. No news</a></div>

  <div class="contentsLine"><a href="#instantiate">8. Instantiate</a></div>
  <div class="contentsLine"><a href="#dataBinding">9. Computed fields and  data binding</a></div>

  <div class="contentsLine"><a href="#update">10. Update</a></div>
  <div class="contentsLine"><a href="#retention">11. Retention of modifications to computed content</a></div>
  <div class="contentsLine"><a href="#save">12. Saving and restoring items</a></div>
  <div class="contentsLine"><a href="#components">13. Components</a></div>
  <div class="contentsLine"><a href="#build">14. Builds and repos</a></div>
  <div class="contentsLine"><a href="#codeBuilt">15. Code-built items, assemblies, and variants</a></div>
  
</div>

<div>   The intended audience  for this document is JavaScript programmers.</div>


<div class="section" id="status">1. Status </div>



<p>The current implementation of PrototypeJungle is a proof of concept.
The core functionalities - the object model, the instantiation operation,  the component system, the framework for geometry and rendering -  are  complete and well tested.
However, the libraries of basic shapes and infographic elements are very sparse, the UI  needs polish and extension, and documentation exists only for the conceptual level, not for the details.
As a result, the system is unlikely to have immediate utility for most infographic projects.
The question is, do  the core capabilites represent something that, if propagated by filling in the sketches at the other levels, would be useful? I think so,  since the output of coding effort in PrototypeJungle will have  more
flexibility in its use by non-programmers than is the case for previous approaches.</p>
<!--
There is enough present so that the underlying idea and its possibilities should be clear, but a system of immediate utility for
infographic projects requires more work.
, due to adjustability all along the prototype chains, and to a more free choice of what constitutes a component
<p>While engaged in this meta-discussion, I will give my own assessment of where the code stands. The object model, as just mentioned, I believe to be in adequate condition for long-term use. The geometry and rendering levels (in the module geom) need much extension, but not,
in my opinion, rewrite. The UI, though it works adequately, needs a rewrite at some point. Some wrong turns in design were made, leading to unnecessary complexity.</p>

  </p> The assembly capability - that is, the capability provided
by the UI to bring in and manipulate a series of items in the style of a  drawing program -  is in a very rough form , but shows
that such a prototype-based drawing program is possible.Aside from general hardening and polishing of the GUI, the  blanks that need filling in include
support for  mouse interaction, both at design time, and view time (viewing by end-users).  Then, of course, useful libraries of components need to be written; from basic things like splines and arrows, up to a variety of complete
infographic widgets (the current flow item provides an example).</p>

<p>The virtues of such a project, if brought to fruition,  would be these. First: the complete
flexibility with which new elements, with all sorts of capabilities for displaying  data (for example), could be added by any coder. Second:
the presence in the assembled drawing of an editable prototype hierarchy, rather than just a collection
of instances.</p>
-->



<div class="section" id="quickStart">2. Quick start</div>

<p>To start experimenting with the system immediately,  you can execute and modify   code examples in the scratch pad:
<a href="/scratch.html?source=tworectangles">two rectangles</a> and <a href="/scratch.html?source=barchart">barchart</a>.
No sign in is required. You can also try a sample <a href="/example_build.html?example=0">build</a>, which allows you to create items that can be subsequently inspected
and edited.  For this purpose, you will need to sign in  (no
registration is needed; you can sign in with your email or twitter account). Here is another <a href="/example_build.html?example=1">sample build</a> with
different initial code.</p>



<!--
<div class="section" id="outline">0. A shift</div>

<p>Prototype Jungle shifts the boundary in application development towards declarative methods and away from coding, in
a particular respect.  Namely, the prototype structure of an application has normally been within the coder's purview, but now is placed
into the domain of declarative structure, where it becomes amenable to GUI-assisted manipulation. The initial implementation only supports
inspection and editing parameters, but assembly is coming soon.</p>
-->

<div class="section" id="overview">3. Overview</div>

<p>
The core operation in the system is instantiation of trees.
This is the analog of <span class="codeWord">Object.create</span>,  but mapped over a tree
of arbitrary depth  rather than applied to a single object.
It creates a new tree, with the same tree structure as the old one, but whose nodes inherit from their
counterparts in the old tree as  <a href="#instantiate">appropriate</a>. The new tree is then modified as needed. (Simple example: a prototype
rectangle is instantiated and then modified as needed to play its role as a bar in a bar chart).  In the initial application domain, the trees
represent computationally defined graphical objects, ranging in complexity from simple shapes (rectangles, arcs, and the like),
up through complete infographic assemblies (eg charts, flow diagrams). 

</p>
<p> Some of the components in the system, the separately storable entities,  are the prototypes at the begining of chains of instantiate/modify steps. But often they represent the instantitate/modify steps themselves.  For example, there is the

<a href="http://prototypejungle.org/inspect?item=http://s3.prototypejungle.org/sys/repo0/chart/Flow">flow diagram</a> component, and there is also the 
<a href="http://prototypejungle.org/inspect?item=http://s3.prototypejungle.org/sys/repo0/chart/variants/Flow/adjusted">adjustment</a> of that diagram with acceptable arrow and text placement. The adjustment is stored as a component too. Components of this kind represent a slice of the bundle of prototype chains that constitute successive instantiations of a tree structure. A <a href="#components">later section</a> describes the situation in more detail.</p>


<div class="section" id="outline">4. Outline of the code base</div>

<p>The code base defines exactly
one global variable, <span class="codeWord">prototypeJungle</span>.  Beneath <span class="codeWord">prototypeJungle</span>  are the modules:</p>
<ul>
    <li>om - the object model</li>
        <li>geom - geometry</li>
    <li>draw - display geometrical objects using HTML5 canvas </li>
    <li>dom - DOM objects</li>
    <li>tree - display the hierarchies of JavaScript objects, and  prototype chains</li>
    <li>page - the web page being built</li>
</ul>

<p>Code files generally specialize in one module or another, but sometimes
add  to more than one module.</p>


<div class="section" id="trees">5. Trees</div>

<p>PrototypeJungle trees are more liberally defined than the strict tree structures required in JSON.
Stated precisely,  a PrototypeJungle tree represents a spanning tree of graph in which  references between nodes other than the parent-child edges are allowed.</p>
<p> Specifically, <span class="codeWord">om.DNode</span> (dictionary node), and <span class="codeWord">om.LNode</span> (list node) are the prototypes for tree nodes. These  differ in that their children are named by sequential integers
starting with zero in the LNode case, and by strings in the DNode case.  All internal nodes in a tree should be of type DNode or LNode (that is, inherit from the prototypes <span class="codeWord">om.DNode,om.LNode</span>).  The leaves can be  atomic values (numbers,
strings,booleans, null, functions).</p>

<div class="clickable" id="openTreeDetails">Coding details for trees</div>
<div id="treeDetails" class="techDetails">
<div class="close" id="closeTreeDetails">X</div>

<p style="padding-top:20px">Tree primitives: </p>
<pre><code>
om.DNode.mk();
</code></pre>

<p> creates a  new <span class="codeWord">DNode</span>, and</p>
<pre><code>
om.LNode.mk();
</code></pre>
<p> a new <span class="codeWord">LNode</span>.</p>
<pre><code>
dpr.set(nm,ch);
</code></pre>

<p>Assigns  <span class="codeWord">ch</span> as the child named <span class="codeWord">nm</span> of <span class="codeWord">pr</span> (a <span class="codeWord">DNode</span>).
Then <span class="code">ch.parent() == dpr, ch.name() == nm, and pr[nm] == ch</span> (child selection on <span class="codeWord">DNodes</span> is ordinary property selection)
</p>

<pre><code>
lpr.pushChild(ch);
</code></pre>

<p>Pushes <span class="codeWord">ch</span> onto the end of the <span class="codeWord">LNode</span> <span class="codeWord">lpr</span>,
and assigns <span class="codeWord">lpr</span> as the parent of <span class="codeWord">ch</span>. Then, <span class="code">lpr[lpr.length-1] == ch,
ch.name() == lpr.length-1, and ch.parent() == lpr</span>.
</p>
<p>
Here is a quick example:
</p>

<pre><code>
var om = prototypeJungle.om;
var root = om.DNode.mk();
var aa = om.DNode.mk();
var bb = om.LNode.mk();

root.set("a",aa); // adds aa as a child named "a" of root
root.set("b",bb);

// introducing the basic operations name and parent:
bb.name();
==>b
bb.parent() == root;
==>true

// let's add some atomic data 
aa.x = 5;  // set is not needed for atomic data 
aa.f = function (x) {return x*x;}

// now for an LNode
var cc = om.LNode.mk();

cc.pushChild(om.DNode.mk().set("z",45));
cc.pushChild(5);

</code>
</pre>
<p>this yields:</p>
<pre><code>
          --root--
        /          \
       a            b
      /              \
     *              [ *, 5]
    / \              /
   x    f           z
  /      \         /
 5    function    45

</code>
</pre>
<p> where * is a DNode</p>

<p>
This could also be built with
</p>

<pre><code>
var root = om.lift({a:{x:5},b:[{z:45,5]})
root.a.f = function (x) {return x*x};
</code></pre>

<p>lift applies to "ordinary" JavaScript trees of the kind directly representable in the object notation.</p>
    

<p>As indicated parenthetically above, there is nothing wrong with having properties of DNodes that reference
nodes in the tree  other than children,  as in </p>

<pre><code>
a.xx = b;
</code></pre>

<p>in the above example.Then xx is a cross-tree reference.</p>
<p><i>Restriction on names</i>: names may include only letters, numerals, and the underbar, and may not start with a numeral.</p>
</div>
<p> We will sometimes use the word "item" in what follows to refer to a DNode/LNode tree. </p>


<div class="section" id="urls">6. URLs for Items</div>

<p> Each externally stored item is referred to by a URL of the form </p>

<pre>
http://s3.prototypejungle.org/&lt;<i>path</i>&gt;
</pre>
<p>for example </p>
<pre>
http://s3.prototypejungle.org/sys/repo0/examples/TwoRectangles
</pre>

<p>To inspect this item, go to</p>
<pre>
http://prototypejungle.org/inspect?item=&lt;<i>itemUrl</i>&gt;
</pre>
<p>for example</p>
<pre>
<a href="http://prototypejungle.org/inspect?item=http://s3.prototypejungle.org/sys/repo0/examples/TwoRectangles">
http://prototypejungle.org/inspect?item=http://s3.prototypejungle.org/sys/repo0/examples/TwoRectangles</a>
</pre>
<p>
To view it without the machinery of the inspector (for example):
</p>
<pre>
<a href="http://s3.prototypejungle.org/sys/repo0/examples/TwoRectangles/view">http://s3.prototypejungle.org/sys/repo0/examples/TwoRectangles/view
</a>
</pre>
<p> You can browse a small set of initial examples via the File pulldown on the top bar.</p>




<div class="section" id="nonews">7. No news</div>
<p> Nodes are constructed with <span class="codeWord">om.DNode.mk()</span> and <span class="codeWord">om.LNode.mk()</span>, rather than via the use of a "new". The definition of the mk method for DNode is:

<pre><code>
om.DNode.mk = function () {
  return Object.create(om.DNode);
}
</code></pre>


<p>Recall that <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create">Object.create</a>(X) creates a new object with X as prototype.
</p>


<p><span class="codeWord">DNode</span> itself is introduced simply with:</p>

<pre><code>
om.DNode = {};
</code></pre>

<p>and <span class="codeWord">LNode</span>  with:</p>


<pre><code>
om.LNode = [];
</code></pre>

<p>
<span class="codeWord">om.DNode</span> itself serves as the prototype for instances.  In the more conventional pattern, <span class="codeWord">om.DNode</span> would be a function, and
the prototype property of that function, not DNode itself, would be the  prototype for the instances, via the new operator (note that if <code>X = function (){}, new X()</code> is equivalent
to <code>Object.create(X.prototype)</code>)
</p>
<p>
The <span class="codeWord"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new">
function, function.prototype, new</a></span> &nbsp; pattern has been in Javascipt all along, whereas the  more direct <span class="codeWord">Object.create</span> was introduced in recent years, in version 1.8.5. PrototypeJungle
employs the newer pattern, not so much for its intrinsic  simplicity (though that's nice), but because this way of doing things has a major
simplifying effect on the entire PrototypeJungle code base. </p>

<p> You will never see a "new" anywhere in the code. The convention is that for prototype  <span class="codeWord">X</span>, <span class="codeWord">X.mk</span> is the creator/initializer (which may take arguments).</p>


<div class="section" id="instantiate">8. Instantiation: the details </div>
<p>

<span class="codeWord">om.DNode.instantiate</span> and <span class="codeWord">om.LNode.instantiate</span>
are the implementation.
The details are a little complicated, but it is the kind of complexity that you don't need to worry about unless you're curious.
Instantiation "does the right thing".</p>

<p>Let <span class="codeWord">T</span>' be the instantiation of tree <span class="codeWord">T</span>. Then <span class="codeWord">T</span>' is a treewise copy of <span class="codeWord">T</span>, but omits its atomic-valued properties (which <span class="codeWord">T</span>' will acquire by inheritance, as will be seen in a moment). That is, with respect to the
labeled parent/child relation, <span class="codeWord">T</span> is isomorphic to <span class="codeWord">T</span>', except for the omission of the atomic-valued properties.  <span class="codeWord">T</span>' also has the same prototype structure as <span class="codeWord">T</span>, except that chains in <span class="codeWord">T</span>' are anchored back in <span class="codeWord">T</span>.
The exact situation is this: consider corresponding nodes <span class="codeWord">N</span> and <span class="codeWord">N</span>' in <span class="codeWord">T</span> and <span class="codeWord">T</span>', that is, nodes appearing at the same paths from the roots of <span class="codeWord">T</span> and <span class="codeWord">T</span>'.
Now consider the prototypes <span class="codeWord">P</span> and <span class="codeWord">P</span>' of <span class="codeWord">N</span> and <span class="codeWord">N</span>', that is, <span class="codeWord">P</span> and <span class="codeWord">P</span>' where
<span class="code">P=Object.getPrototypeOf(N)</span> and <span class="code">P'=Object.getPrototypeOf(N')</span>. There
are two cases. First, <span class="codeWord">P</span> might lie within <span class="codeWord">T</span>. Then <span class="codeWord">P</span>' is defined to be the corresponding node to <span class="codeWord">P</span>, treewise (ie the one at the same path). Second,
<span class="codeWord">P</span> might lie outside of the tree <span class="codeWord">T</span>.  Then <span class="codeWord">P</span>' is set to <span class="codeWord">N</span> itself. This is what I mean when I say that prototype chains in <span class="codeWord">T</span>' are anchored in <span class="codeWord">T</span>. If you follow
a prototype chain <span class="codeWord">C</span>' in <span class="codeWord">T</span>', it will pass through nodes at the same paths as those of the corresponding chain <span class="codeWord">C</span> in <span class="codeWord">T</span>,
as long as it is within the tree, but where it exits the tree, then it is 
anchored back over in <span class="codeWord">T</span>.</p>
<p><a href="https://github.com/chrisGoad/prototypejungle/blob/master/www/js/instantiate.js">Here</a> is the implementation.</p>

<div class="section" id="dataBinding">9. Computed fields and  data binding</div>
<!--
<p><a href="http://d3js.org">D3</a> provides an effective approach for binding data to the DOM. PrototypeJungle is based on a different (and
simpler) object model, but, nonetheless, the D3 concepts apply well. Only  the core operations from D3
are present in PrototypeJungle so far. -->
<p> 
    A field in an item can be specified by a function rather than a literal value, and when data is bound to the item,
    the fields take on their computed values.  For example, consider
</p>
<pre><code>
    // ccP is a circle with a caption
    var ccP = geom.Shape.mk().withComputedFields();
    ccp.scale = 2;
    ccP.set("circle", geom.Circle.mk({
      // a computed field
      radius: [function (item,area) {return item.scale* Math.sqrt(area);}]
    }));
   
    ccP.set("caption",geom.Text.mk({
    // and another
      "text":[function (item,area) {return area}],
      style:{height:13}}));
  
    var iccP = ccP.instantiate(); // an instance
    iccP.setData(100);
</code></pre>

<p>The   result, <span class="codeWord">iccP</span>,  is a captioned circle with area 20 <span class="codeWord">(Math.sqrt(100) * ccP.scale)</span>, and caption "100".</p>
<p><span class="codeWord">setData</span> is the general data binding method:  whenever you wish to declare a way
of binding data to any type of item, you should define this method on the relevant prototype. For items so declared using the <span class="codeWord">withComputedFields</span> method, <span class="codeWord">setData</span> is predefined to evaluate
the computed fields, and replace  them with their values.</p>

<p>The rules are apparent from the example: within an item to which withComputedFields has been applied,  
 one-member arrays containing a function signify  a computed field of the item. Such fields may appear at arbitrary depth. The function should take two arguments, the item, and the data value. 
</p>

<p>This construct becomes particularly useful in the context of mark sets ("mark" is a conventional term used in infographics
to designate a shape whose parameters are set according to the data to be represented)  

<p>A mark set holds two arrays (as LNodes), one containing data, and the other shapes. 
The two arrays might be of different lengths, but where they correspond, each shape is normally bound to the corresponding data element,
though they can be out of sync in the course of some computations.
</p>
<p>
<span class="codeWord">geom.Marks</span> is the prototype for
mark sets. Continuing the example:</p>

<pre><code>
var marks = geom.Marks.mk([100,200,300],ccP);
</code></pre>


<p><span class="codeWord">geom.Marks.mk(data,proto)</span> constructs an mark set, whose members are instantiations of proto, bound in sequence to
the elements of data. In our example, this is an array of captioned circles with areas and captions 100,200, and 300.
</p>

<p>
    
    <a href="http://prototypejungle.org/inspect?item=http://s3.prototypejungle.org/sys/repo0/examples/variants/Carbon/adjusted">Here</a> is a simple but complete example depicting carbon footprints of the top emitters.
    <a href="http://prototypejungle.org/inspect?item=http://s3.prototypejungle.org/sys/repo0/examples/Carbon">Here</a> is the unadjusted version, and a <a href="http://s3.prototypejungle.org/sys/repo0/examples/Carbon/source.js">shortcut</a> to the code.
</p>
<p>
Computational definitions of field values invoked by data binding will be  familiar to users
    of <a href="http://d3js.org">D3</a>. Mark sets are a little like D3 selections, but differ in that they
    are parts of the core object model, rather than selections from it (the object model being the DOM in the case of D3).
</p>
    
    <!--
<div class="section" id="D3">9. D3-style selections for the PrototypeJungle object model</div>
<p>
    Computational definitions of field values invoked by data binding will be  familiar to users
    of <a href="http://d3js.org">D3</a>. Another core concept from  D3, the <span class="codeWord">selection</span> into which data comes and from which it goes,  applies well in the PrototypeJungle setting,
    even though the underlying object model is different (D3 applies to the DOM).</p><p> <span class="codeWord">geom.Selection</span> is a  collection
    of pairings of data with shape, where either shape or data might be missing. 
    Here are some methods:
</p>

<pre><code>

Marks.enter()    - returns the enter selection from the marks, in the D3 sense: it contains
                 - the unbound data elements - that is, the elements for which there is no shape
                
                
Marks.exit()      - the unbound shapes 

Selection.data(dt)      - sets the data of the selection to dt, without changing the shapes
Selection.complete(p)   - For each unbound data element d, p is instantiated and bound to d, and
                        - the result is added to the underlying mark set.
                        - This is similar to D3's selection.append
                        - but restricted to unbound data.
                

Selection.extend(p)  - Here, p is often an item with computed fields. In any case, for each
                     - bound shape in the selection, the operation instantiates p,
                     - binds it to its corresponding data element, and then deeply merges
                     - the result into the shape.  This is the generalized counterpart
                     - of the D3 operations: selection.style, selection.html, selection.text,
                     - selection.attr, and selection.property. The simplicity of the PrototypeJungle
                     - object model relative to the DOM cuts down on the number of operations
                     - needed to adjust an object.
                     
              
Selection.remove()   - removes all members and corresponding data from the underlying mark set. Returns the empty selection
Selection.update()   - rebinds data to shapes.
</code></pre>

-->
          
<div class="section" id="update">10. Update</div>

<p>Items can  be defined by computation in a more general manner than just described.  This is done by defining "update" methods which compute
the full state of an item in any way that is suitable to the application.  When an item is displayed in the PrototypeJungle viewer or inspector, update methods
are run at load time, and each time there is a change. Specifically, to update an item, a depth first traversal
of the tree is done with the rule: when an update method is present for the current node, execute it.  Traversal terminates
at the point where update methods are found. </p>

<p> Here is an example:</p>

<pre id="NestedArcs"><code>

//a collection of nested arcs 
(function (pj) {
  var om = pj.om; 
  var geom = pj.geom;
  var item = pj.set("/examples/NestedArcs",geom.Shape.mk());
  item.namedType();
  //The arc prototype. 
  var ArcP=item.set("ArcP",geom.Arc.mk({radius:100,startAngle:0,endAngle:2*Math.PI})).hide();
  item.radiusFactor = 0.9;
  item.count = 10;
  item.update = function () {
    var om = prototypeJungle.om;
    var arcs = om.LNode.mk().computed();
    this.set("arcs",arcs);
    var crad = this.ArcP.radius;
    var cnt = this.count;
    for (var i=0;i&lt;this.count;i++) {
      var ca = this.ArcP.instantiate().show();
      arcs.pushChild(ca);
      ca.setf("radius",crad);  // freeze the radius
      crad = crad * this.radiusFactor;
    }
  };
  om.save(item);
})(prototypeJungle);

</code></pre>



<p>This yields</p>

<pre>
<a href="http://s3.prototypejungle.org/sys/repo0/examples/NestedArcs/view">http://s3.prototypejungle.org/sys/repo0/examples/NestedArcs/view</a>
</pre>
<p>
via the <a href="#build">build</a> process. 
To inspect, see:</p>
<pre>
<a href="http://prototypejungle.org/inspect?item=http://s3.prototypejungle.org/sys/repo0/examples/NestedArcs">
http://prototypejungle.org/inspect?item=http://s3.prototypejungle.org/sys/repo0/examples/NestedArcs</a>
</pre>


<p>A few explanations are needed:</p>



<pre><code>
  var item = pj.set("/examples/NestedArcs",geom.Shape.mk());

</code></pre>
<p><span class="codeWord">geom.Shape</span> is the prototype for all displayable objects, and inherits from <span class="codeWord">om.DNode</span>. <span class="codeWord">geom.Shape.mk()</span>
constructs an empty container to which other shapes can be added.
</p>


 <pre><code>
  item.namedType();
 </code></pre>

<p>This has a minor effect: an item <span class="codeWord">x</span> will be displayed as <span class="codeWord">x:NestedArcs</span>
in the inspector if <span class="codeWord">NestedArcs</span> is the
first object flagged as a named type in its prototype
chain. There is nothing otherwise special about named types; any item can be flagged as such, affecting only display.
</p>

<pre><code>

 item.update = function () {
    var om = prototypeJungle.om;
    ...
</code></pre>

<p>Why does <span class="codeWord">om</span> need redefinition in the <span class="codeWord">update</span> function? Isn't the definition of <span class="codeWord">update</span>
inside the scope of the main function, where <span class="codeWord">om</span> is available?  It may look that way, but, once the item is built,
this is no longer the case. The update function is inserted into the item
itself during the build process - it ends up as a leaf in the item's tree. So it needs to be able to run without assuming anything about the
scope, with the single exception that the global <span class="codeWord">prototypeJungle</span> will have been defined. Of course, as a method
of the item, it has full access to it via <span class="codeWord">this</span>.
</p>

<pre><code>
    var arcs = om.LNode.mk().computed();
</code></pre>

<p>When an item is declared <span class="codeWord">computed</span>, it is removed before saving, with the assumption that
it will be recomputed by an update on reloading.
<!--To check in the inspector on what's computed, choose "manual update" in "options", then click the "remove computed" button.</p>-->



<pre><code>
      ca.setf("radius",crad);  // freeze the radius
</code></pre>

<p>Normally, all atomic properties are editable in the inspector.  The <span class="codeWord">setf</span> method, however, declares
that the property in question should be "frozen", that is, closed from modification in the inspector.
Only the inspector is affected, the property is not modified at the deeper JavaScript level (its 
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">
descriptor</a> is not modified).

</p>


<div class="section" id="retention">11. Retention of modifications to computed content</div>
<p>Computed content can be modified in the inspector,  and these modifications will be retained through subsequent
updates, saves, and restores. The implementation keeps track of modifications, 
and, whenever an update is done, reapplies the modifications to the updated state.  </p>


<div class="section" id="save">12. Saving and restoring items</div>
<p>Earlier sections implicitly introduced the fact that items can be saved and restored
 with their prototype structures and functions  intact. But there is one more aspect of this process
 that needs mention: one file can reference items from others, often using them as prototypes.
The prototype chain for an item might have elements from several separate
files. Here is an example:</p>


<pre><code>
(function (pj) {
  pj.om.restore(["http://s3.prototypejungle.org/sys/repo0/examples/NestedArcs"],
    function () {
      var om = pj.om;
      var geom = pj.geom;
      var item = pj.set("/examples/TwiceNestedArcs",geom.Shape.mk());
      var n1  = item.set("n1",pj.examples.NestedArcs.instantiate());
      var n2  = item.set("n2",pj.examples.NestedArcs.instantiate());
      
      // adjust some parameters
      n2.ArcP.radius = 30;
      n2.ArcP.style.strokeStyle = "red";
      om.save(item);
    }
  );
})(prototypeJungle);
</code></pre>



<p> Recall that 
<span class="codeWord">http://prototypejungle.org/sys/repo0/examples/NestedArcs</span> contains the definition
of the prototype <span class="codeWord">NestedArcs</span> which
appears in an earlier <a href="#update">section</a>. Here the restore operation loads that definition in, prior to defining
a simple structure in which <span class="codeWord">NestedArcs</span> is instantiated. The details:

<pre><code>
om.restore([&lt;file0>,&lt;file1>...&lt;/filen>],fn);
</code></pre>

<p>
restores the indicated files in order, and when it is done, calls the function <span class="codeWord">fn</span>.
<span class="codeWord">fn</span> might take one
argument, and, if so, <span class="codeWord">fn</span> is called with an array consisting of the items restored from the files <span class="codeWord">[&lt;file0&gt;,&lt;file1&gt;...&lt;/filen&gt;]</span>.
Often, though, as in this example, the purpose of restoring files is to populate the <span class="codeWord">prototypeJungle</span> tree with  particular
items, and <span class="codeWord">fn</span> takes no arguments.</p>


<p>The TwoNestedArcs structure is saved in
<a href="http://s3.prototypejungle.org/sys/repo0/examples/TwiceNestedArcs/view">http://s3.prototypejungle.org/sys/repo0/examples/TwiceNestedArcs/view</a></p>

<div class="section" id="components">13. Components</div>

<p>The save algorithm notices when parts of what it is saving come from other files,
and mentions them by reference in the saved structure.  This usually involves splitting up prototype chains; earlier parts of the chain
might come from one place, and later elements from another (an arbitrary number of  sources might be involved).
For example <span class="codeWord">TwiceNestedArcs.n1</span>, as saved, has six elements in its prototype chain: <span class="codeWord">n1</span> itself,
<span class="codeWord">NestedArc</span>, <span class="codeWord">Shape</span>,<span class="codeWord">DNode</span>, <span class="codeWord">{}</span> (the vanilla
object built in om.js to be the prototype of <span class="codeWord">DNode</span>), and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/prototype">Object.prototype</a>,
the <a href="http://en.wikipedia.org/wiki/Eve">mother</a> of all JavaScript objects.
The first four are defined in the files: <a href="http://s3.prototypejungle.org/sys/repo0/examples/TwiceNestedArcs/source.js">TwiceNestedArcs</a>,
<a href="http://s3.prototypejungle.org/sys/repo0/examples/NestedArcs/source.js">NestedArcs</a>, <a href="https://github.com/chrisGoad/prototypejungle/blob/master/www/js/pj.js">om</a>, and
<a href="https://github.com/chrisGoad/prototypejungle/blob/master/www/js/pj.js">om</a> respectively. </p>

<p>If you are interested in visualizing the structure of a PrototypeJungle application, here is one way to do it.  The fundamental
operation, <a href="#instantiate">instantiate</a>, takes a tree, and pulls off a copy, but leaves prototype chains anchored in  the original.  <!--(You might fancifully imagine the prototype links as vines, thus connecting to the image
of a jungle.) --> If instantiation is done several times in succession, a series of trees with their prototype backpointers arises. The same  tree might be
instantiated multiple times, in which case one arrives at a tree of trees. At each step,
modifications are made  - that is, parameters are set.</p>
<p> The components represent slices of this structure. So, for example, I might have the general arrow, next a selection of some parameters that I wish to apply to  all of the arrows in my particular application, and finally the exact configuration
of one particular arrow. The prototype chains connecting this tree of trees are each
three long. Each tree is a separable component, and its representation
can reside in its own file if desired, for re-use outside of a particular PrototypeJungle running instance.</p>


<p>A more extensive and realistic example of building up prototype chains from a series of saved items can be found
in the <a href="/barchartLinks.html">bar chart</a> example.</p>


<div class="section" id="build">14. Builds and repos</div>
<p>When you first sign in at PrototypeJungle, you choose a handle, and thereafter, all of your content will be stored under</p>
<pre>
http://s3.prototypejungle.org/<i>yourHandle</i>
</pre>
<p>(this is the only purpose of the handle). Within this
filespace your content is organized into <i>repos</i>, of which you may allocate as many as you like. (Activities related to building items,
including allocation of repos,
are accessible from the  "file" pulldown in the topbar.) Within repos, items should be given paths that correspond
to the paths under which they will appear when loaded into PrototypeJungle. For example, the system handle is "sys", and all the content mentioned
here appears within the repo "repo0".  The item which is stored at </p>
<pre>
http://s3.prototypejungle.org/sys/repo0/examples/NestedArcs
</pre>
<p>
gives itself
the path <span class="codeWord">/examples/NestedArcs</span>, that is, the same pathname as the one at which the item is stored externally, relative to its repo. That is, the external tree structure of each repo mirrors a corresponding structure at runtime for the tree rooted at prototypeJungle.</p>
<p>
The following is the relevant line of  <a href="#NestedArcs">source</a> code:</p>

<pre>
var item = pj.set("/examples/NestedArcs",geom.Shape.mk());
</pre>
<p>When you build a new item, the source code is initialized to a template that includes a line of this form, with the appropriate path.</p>
<p>More specifically, the process of building a new item is this: First, after choosing "New Build" from the File pulldown, choose where to put
the item. At the time
of clicking the "Build New Item" button on the file browser,  template source code as just described will appear in the <a href="http://ace.c9.io">Ace Code Editor</a>. Edit to taste, then click
"build", and thence a new item is created.</p>

<div class="section" id="codeBuilt">15. Code-built Items, Assemblies, and Variants</div>

<p>An item can come into being in three ways. First, it can be built from a code file, as described above. Second, it can be  a <i>variant</i>- the
result of interactively  modifying an existing item, and then storing the result with the "save as" option in the File pulldown.
Finally, it might be an <i>assembly</i>, built in the UI starting from a blank slate, via an initial "New Item", followed by a series of insertions.
  </p>
<p>You will notice these distinctions in some of the operations of the UI.  For example, only code-built items can be rebuilt (for other
items this option is grayed-out in the File pulldown).  You are not allowed overwrite a code-built item with a variant with a simple
save; you must save the variant somewhere else, with "save as". The UI attempts to find a suitable name for new saves based on these distinctions.But the names  are only suggestions; you can put things where you want.</p>

<!--
<div class="section" id="other">11. Other applications</div>

<p>The initial application area of Prototype Jungle is 2d graphics, but only a little of the code is associated with that particular application.
The capabilities of  browsing, editing, and saving  underlying prototype structures  are  application independent. To choose a random example,
music makes a lot of sense as an application:  what is an instrument, but an element of  a prototype chain originating with Note and terminating in a particular
played sound?
</p>
-->



</div>
</body>
</html>