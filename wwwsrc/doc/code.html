{{boilerplate}}
<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.0/jquery.min.js"></script>

<script>
var documentReady = 0;
var initPage = function () {

    $('#openTreeDetails').click(function () {
        $('#treeDetails').show();
    });
     $('#closeTreeDetails').click(function () {
        $('#treeDetails').hide();
    });
       $('#openInstantiateDetails').click(function () {
        $('#instantiateDetails').show();
    });
    $('#closeInstantiateDetails').click(function () {
        $('#instantiateDetails').hide();
    });
}


$('document').ready(function () {
  documentReady = 1;
  initPage();
});
</script>



  
<div class="pageTitle">Coding Guide</div>
<p> PrototypeJungle users can code their own visual elements and diagrams via the code editor, and assemble catalogs of these
new elements via the catalog
editor. Subsequently, such elements and diagrams are available for use in PrototypeJungle's UI, where no coding is required. In addition, the
core technology is openly available under the MIT Licence for use in any application. This document provides the information needed for both
activities.</p>

<p>
Sections 3 - 5  describe how to work with <a href="/doc/tech.html">prototype trees</a>,
the material from which all PrototypeJungle elements (referred to as "items") are made.<!--
This is a general purpose
JavaScript component technology hosted at prototypejungle.org. Deep prototypes are the material from which all PrototypeJungle elements are made.-->
  The remaining sections concern  construction of and interaction with 2d shapes implemented by way  of
<a href="https://developer.mozilla.org/en-US/docs/Web/SVG">SVG</a>.
</p>

<div class="tableOfContents"> 
    <div class="contentsLine"><a href="#quickStart">1. Quick Start</a></div>
   <div class="contentsLine"><a href="#codeStructure">2. Code Structure</a></div>
     <div class="contentsLine"><a href="#trees">3. Trees</a></div>
      <div class="contentsLine"><a href="#instantiation">4. Instantiation and Serialization</a></div>
   <div class="contentsLine"><a href="#nonews">5. No news</a></div>  
  <div class="contentsLine"><a href="#svg">6. SVG</a></div>
     <div class="contentsLine"><a href="#conventions">7. Naming Conventions</a></div>

   <div class="contentsLine"><a href="#update">8. The Update Method</a></div>
    <div class="contentsLine"><a href="#controllers">9. Controllers</a></div>
       <div class="contentsLine"><a href="#drag">10. Dragging and Cloning</a></div>
       <div class="contentsLine"><a href="#files">11. Files</a></div>
       <div class="contentsLine"><a href="#licensing">12. Licensing Status of Code</a></div>
        <div class="contentsLine"><a href="#catalogs">13. Catalogs</a></div>
       <div class="contentsLine"><a href="#visibility">14. Controlling Access to Properties</a></div>
        <div class="contentsLine"><a href="#API">15. API</a></div>
                 <div class="contentsLine"><a href="#spreads">16. Spreads</a></div>
         <div class="contentsLine"><a href="#share">17. Sharing Your Work</a></div>



</div>

<div class="section" id="quickStart">1. Quick Start </div>
<p style="margin-bottom:20px"> Consider this
simple diagram</p>
<p>
 <img id="diagram" height="40px" src="https://firebasestorage.googleapis.com/v0/b/project-5150272850535855811.appspot.com/o/twitter%3A14822695%2FforDocs%2Flogo.svg?alt=media"</img>
</p>
<p> which  was produced by the following code:<!-- (it could also have been built without coding in the editor):-->
</p>

<precode>

pj.require('/shape/circle.js','/shape/arcArrow.js',function (circlePP,arrowPP) {
  var geom = pj.geom;
  var svg = pj.svg;
  var item = svg.Element.mk('&lt;g/&gt;');// the root of the diagram we are assembling
  item.p1 = geom.Point.mk(-50,0);
  item.p2 = geom.Point.mk(50,0);
  // the circle prototype
  var circleP = item.set('circleP',circlePP.instantiate()).__hide();
  circleP.__dimension = 20;
  circleP.fill = 'blue';
  // instantiate it twice
  item.set('circle1',circleP.instantiate()).__show();
  item.set('circle2',circleP.instantiate()).__show();
  item.circle1.__moveto(item.p1);
  item.circle2.__moveto(item.p2);
  // now the arrows 
  var arrowP = item.set('arrowP',arrowPP.instantiate()).__hide();
  // set some parameters of the arrow prototype
  arrowP.stroke = 'orange';
  arrowP.radius = 1; // radius of the arc as a multiple of arrow length
  arrowP.tailGap = 15; // gap between tail of arrow and its designated start point
  arrowP.headGap = 15; // gap between head of arrow and its designated end
  arrowP.solidHead = false;
  // instantiate it twice
  item.set('arrow1',arrowP.instantiate()).__show();
  item.set('arrow2',arrowP.instantiate()).__show();
  item.arrow1.setEnds(item.p1,item.p2); //set start and end points of the arrow
  item.arrow2.setEnds(item.p2,item.p1);
  return item;
});


</precode>
<p>
<a href="/draw.html?source=/example/simpleDiagram.js">
  https://prototypejungle.org/draw.html?source=/example/simpleDiagram.js
</a> displays the diagram in the drawing UI, where its structure 
is made visible, and can be modified.   The UI is explained
<a href="http://127.0.0.1:3000/draw.html?source=(sys)/forMainPage/intro_tree.item&intro=intro&fit=0.5">here</a></p>

<p> You can also view the diagram in the code editor, where you can experiment with code changes (however, if you wish to save changes you
will need to sign in and save the code to a file of your own). Here's the URL: <a href="/code.html?source=/example/simpleDiagram.js">
  https://prototypejungle.org/code.html?source=/example/simpleDiagram.js
</a>
From the code editor, you can get to the drawing UI opened on the same diagram with the top bar operation "edit structure", and from drawing  to code editing
with the "code" top bar op.</p>
 </p>
<p>Note: Browser debuggers (eg <a href="https://developer.chrome.com/devtools">Chrome's DevTools</a>) work well with the code editor. </p>
  <p> Let's walk through the code:</p>
  <precode>
    pj.require('/shape/circle.js','/shape/arcArrow.js',function (circlePP,arrowPP) {
</precode>
  <p>
<i><b>pj</b></i>: The PrototypeJungle implementation is installed under one global variable,  <cw>prototypeJungle</cw>.
A shorter synonym for that global, <cw>pj</span>, is also available. If you need <cw>pj</span> for other purposes,
it can be freed by calling <cw>prototypeJungle.noConflict()</span>
(this is analogous to <a href="https://api.jquery.com/jquery.noconflict/">jQuery.noConflict()</a>, which frees up $). 
</p>

<p> To continue:
 <cw>
 pj.require('/shape/circle.js','/shape/arcArrow.js',function (circlePP,arrowPP) {...

 </span>
 binds the variables <cw>circlePP</cw> and  <cw>arrowPP</span> to the components defined in <cw>'/shape/circle.js'</span>, and
 <cw>'/shape/arcArrow.js'</span>, respectively. More generally, consider:
 </p>

<precode>
     pj.require(file1,file2,...,file<sup style="font-size:8pt">n</sup>,function (var1,var2,...,var<sup style="font-size:8pt">n</sup>) { ...});
 </precode>


<p>
Each variable <cw>var<sup style="font-size:8pt">k</sup></span> is bound to the component defined by the corresponding file <cw>file<sup style="font-size:8pt">k</sup></span>.
</p>
<precode>
    var item = svg.Element.mk('&lt;g/&gt;');// the root of the diagram we are assembling
</precode>

 

<p><cw>pj.svg.Element.mk</span> creates a prototype tree from
<a href="https://developer.mozilla.org/en-US/docs/Web/SVG">SVG</a> markup.
In what follows, prototype trees will be referred to as "items".</p>

<precode>
    item.p1 = geom.Point.mk(0,0);
    item.p2 = geom.Point.mk(100,0);
</precode>

<p> points are items (that is, prototype trees) too. </p>
<!--
<p>The prototype for the circles is defined by:</p>
<precode>
    item.set('circleP',svg.Element.mk(
       '&lt;circle fill="rgb(39, 49, 151)" stroke="black" stroke-width="2" r="5"/&gt;').__hide());
</precode>
-->

<p>For any <cw>item</span>, </p>

<precode>
    item.set('name',ch);
</precode>

<p>assigns <cw>ch</span> as the child of <cw>item</span>
with the given <cw>name</cw>,  so that <cw>item.name === ch</span>. Items are always trees, not graphs, in their own-property aspect.
Thus, for no other <cw>item2</cw> with own property <cw>'prop'</cw> does <cw>item2.prop === ch</cw>.</p>
<p>Next:</p>

<precode>
    var circleP = item.set('circleP',circlePP.instantiate()).__hide();
</precode>
<p>
and a few lines later:
</p>
<precode>
  item.set('circle1',circleP.instantiate()).__show();
</precode>


<p>
Instantiate is the fundamental operation in PrototypeJungle:
it  is the analog of <cw>Object.create</span>, but works for trees of arbitrary depth.  As it happens,
circles have depth 1,  but arrows, instantiated  later, are of depth 2.  <cw>X.instantiate() </cw> is, roughly speaking, a tree-wise copy of <cw>X</cw>,
but the copying is only applied to internal nodes; atomic properties
are inherited. Here are the <a href="/doc/tech.html#instantiate">details</a>.
</p>


<p>There is a reason for instantiating <cw>circlePP</cw> to <cw>circleP</cw>, and then <cw>circleP</cw> to <cw>circle1</cw> and
<cw>circle2</cw>, rather than deriving <cw>circle1</cw>
and <cw>circle2</cw> directly from <cw>circlePP</cw>. Namely, <cw>circlePP</cw>, having come into being via a require,
is an external reference of the item we are building. <cw>circleP</cw>, on the other hand, is an internal structure.
<cw>circlePP</cw>'s properties (eg fill or r) are not available for modification,whereas <cw>circleP</cw>'s are.</p>
<p>
Anyway, via instantiation, we get two circles and two arrows, which are then given the differing properties appearing in the diagram. The unmodified properties are inherited. Instantiation is used at all levels - for comparatively simple components like arrows, but also for complete diagrams.
</p>

<!--
<p>
<precode>
    pj.returnValue(undefined,item);
</pre></code>
</p>
<p>
returns item as the value of the component.</p>-->
<p>To complete the explantion of this bit of code:  <cw>__show</cw>, <cw>__hide</cw>, and <cw>__moveto</cw> are methods of
<cw>pj.svg.Element</cw> (the prototype which implements drawable shapes based on svg Elements).
<cw>setEnds</cw> is a method of  the arcArrow prototype, whose implementation can be viewed at
<a href="/code.html?source=/shape/arcArrow.js">https://prototypejungle.org/code.html?source=/shape/arcArrow.js</a>.
The stroke, r and fill properties implement the SVG properties of the same name. The meanings of other properties (headGap, tailGap)
</p>
<p>
 Any item may be displayed in the editor or assembled into larger structures via require.
</p>
<!--
<p>

Items can also be displayed outside of the editor, as illustrated in the file
<a href="https://prototypejungle.org/repo1/example/standalone.html">https://prototypejungle.org/repo1/example/standalone.html</a>.
Use your browser's <i>view source</i>  to see how this works.
<a href="https://prototypejungle.org/repo1/example/standalone2.html">https://prototypejungle.org/repo1/example/standalone2.html</a>, is similar
but builds the item inline rather than requiring it from simple_diagram.js.
The second variant is available at
<a href = "https://jsfiddle.net/tasp1umh/">jsfiddle</a></p>
<p>
PrototypeJungle also has a viewer:<br/> <a href="https://prototypejungle.org/view.html?source=https://prototypejungle.org/repo1/example/simple_diagram.js">
https://prototypejungle.org/edit.html?source=https://prototypejungle.org/repo1/example/simple_diagram.js</a>
</p>
-->




<div class="section" id="codeStructure">2. Code Structure </div>

<p>The PrototypeJungle implementation has three levels. First, there  is the core, in which prototype trees
and their basic operations, including serialization and instantiation, are defined. The second level supports
prototype trees in the context of 2d graphics. <!--
Protototypes are provided for 2d graphical shapes and their operations, and for sets of infographic marks
with data binding. -->This level of the implementation relies on
<a href="https://developer.mozilla.org/en-US/docs/Web/SVG">SVG</a>. The third level implements the ProtoypeJungle user interfaces found in
the structure editor (draw), the code editor, and the catalog editor.
The first two levels are independent of the PrototypeJungle website, and could be used in any JavaScript application, whereas the third is in various
ways connected to the website (the latter code could be adapted for other situations, though).
</p>


<p>The first two levels are implemented by 
<a href="https://prototypejungle.org/js/core-0.9.3.js">https://prototypejungle.org/js/core-0.9.3.js</a> and
<a href="https://prototypejungle.org/js/dom-0.9.3.js">https://prototypejungle.org/js/dom-0.9.3.js</a>.
There are minimized versions: https://prototypejungle.org/js/core-0.9.3.min.js and https://prototypejungle.org/js/dom-0.9.3.min.js.
Include these lines in applications:</p>

<precode>
&lt;script src="https://prototypejungle.org/js/core.0.9.3.min.js"&gt;&lt;/script&gt;
&lt;script src="https://prototypejungle.org/js/dom-0.9.3.min.js"&gt;&lt;/script&gt;
</precode>

<p>
 All code (organized into smaller files) is at <a href="https://github.com/chrisGoad/prototypejungle/tree/master">GitHub</a>, and is open source under the
MIT License.</p>
<!--
<p> For charts, there is a fourth level of code: the code that implements the charts themselves, and their components
such as axes and legends.  The code for these appears in the current prototype repository: https://prototypejungle.org/repo3/charts, and also at github.
-->


<!--Not much will be said about the editor in this document.-->


<div class="section" id="trees">3. Trees</div>

<p> All prototype trees (aka "items") are trees: each non-atomic child 
has a unique parent. (Formally, if <cw>parent.prop === child</cw>, and <cw>prop</cw> is an own property of <cw>parent</cw>,
there is no <cw>parent2</cw> with <cw>parent2 !== parent</cw>, and
with <cw>parent2.prop2 === child</cw> for own property <cw>prop2</cw> of <cw>parent2</cw>). 
 The internal nodes in items  inherit from prototypes <cw>pj.Array</cw>
for sequential, zero-based arrays, and <cw>pj.Object</cw>  for objects which are not arrays.  

</p>

<precode>  
pj.Object.mk();
</precode>

<p> creates a  new <cw>Object</span>, and</p> 
<precode>
pj.Array.mk();
</precode>
<p> a new <cw>Array</span>.</p>
<p> 
<precode>
object.set('name',child);
</precode>

<p>assigns <cw>child</span> as a child of 
<cw>object</span> with name <cw>name</span>.
If <cw>child</span> is an Object or Array, this results in setting special properties:
<cw>child.__parent === object</span>, and <cw>child.__name === 'name'</span>.</p>

<p> For an Array,</p>
<precode>
array.push(child);
</precode>

<p>pushes <cw>child</span> onto the end of  <cw>array</span>,
and assigns <cw>array</span> as the parent of <cw>child</span>. That is,
<span class="code">array[array.length-1] === child</span>, and if <cw>child</span> is an Object or Array,
and <span class="code">child.__parent === array</span>. Also, <span class="code">child.__name === array.length-1</span>.
Arrays are always sequential and zero-based.
</p>



<pre id="lift"><code>
pj.lift(obj);
</code></pre>


<p>takes an "ordinary" Javascript tree such as one expressable in JavaScript object notation,
and turns it into the PrototypeJungle kind of tree. 
For example: </p>
<precode>
pj.lift({a:2,b:["a",4]});
</precode>

<p> will produce a Object/Array tree with matching structure.  </p>


<p>Click <span class="clickable" id="openTreeDetails">here</span> for an example of tree construction and manipulation.</p>
<div id="treeDetails" class="techDetails">
<div class="close" id="closeTreeDetails">X</div>



<precode>
var root = pj.Object.mk();
var aa = pj.Object.mk();
var bb = pj.Object.mk();

root.set("a",aa); // adds aa as a child named "a" of root
root.set("b",bb);

// __name and __parent "glue the tree together".
bb.__name;
==>b
bb.__parent === root;
==>true

// let's add some atomic data 
aa.x = 5;  // set is not needed for atomic data or functions
aa.f = function (x) {return x*x;}

// now for an Array
var cc = pj.Array.mk();
bb.set("c",cc);

cc.push(pj.Object.mk().set("z",45));
cc.push(5);

</code>
</pre>
<p>this yields:</p>
<precode>
          --root--
        /          \
       a            b
      / \            \
     x   f            c
    /     \            \
   5    function      [ *, 5]
                       /
                      z
                     /
                    45
   

</code>
</pre>
<p> where * is an Object</p>

<p>
This could also be built with
</p>

<precode> 
var root = pj.lift({a:{x:5},b:{c:[{z:45},5]}})
root.a.f = function (x) {return x*x};
</precode>


<p>There is nothing wrong with having properties of Objects that reference
nodes in the tree  other than children,  as in </p> 

<precode>
a.xx = b; 
</precode>
 
<p>in the above example.Then xx is a cross-tree reference.</p>
<p><i>Restriction on names</i>: names may include only letters, numerals, and the underbar, and may not start with a numeral.</p>
</div>

<div class="section" id="instantiation">4. Instantiation and Serialization</div>
<precode> 
inode = node.instantiate();
</precode>

<p> builds an instantiation of <cw>node</cw>; a tree which has the same structure as <cw>node</cw>, but inherits primitive
data and functions from <cw>node</cw> via prototypical inheritance. (Details
<a href="/doc/tech.html#instantiate">here</a>)</p>
<p id="serialization">Serialization is performed by: 
<precode> 
s = pj.stringify(node);
</precode>

<p> as described <a href="/doc/tech.html#serialize">here</a>.</p>


<div class="section" id="nonews">5. No news</div>
<p> Nodes are constructed with <cw>pj.Object.mk()</span> and <cw>pj.Array.mk()</span>, rather than via the use of a "new".
The definition of the <cw>mk</cw> method for <cw>Object</cw> is:

<precode>
pj.Object.mk = function () {
  return Object.create(pj.Object);
}
</precode>


<p>Recall that <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create">Object.create</a>(X) creates a new object with X as prototype.
</p>


<p><cw>Object</span> is introduced simply with:</p>

<precode>
pj.Object = {};
</precode>

<p>and <cw>Array</span>  with:</p>


<precode>
pj.Array = [];
</precode>

<p>
<cw>pj.Object</span> itself serves as the prototype for instances.  In the more conventional pattern, <cw>pj.Object</span> would be a function, and
the prototype property of that function, not <cw>Object</cw> itself, would be the  prototype for the instances generated via the new operator
(note that if <code>F = function (){}, new F()</code> is equivalent
to <code>Object.create(F.prototype)</code>)
</p>
<p>
The <cw><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new">
function, function.prototype, new</a></span> &nbsp; pattern has been available in JavaScript all along,
whereas the  more direct <cw>Object.create</span> was introduced more recent years (in version 1.8.5 to be exact). PrototypeJungle
employs the newer pattern, not so much for its intrinsic  simplicity (though that's nice), but because this way of doing things has a major
simplifying effect on the entire PrototypeJungle code base. </p>

<p> You will never see a "new" anywhere in the code. The convention is that for prototype  <cw>X</span>, <cw>X.mk</span> is the creator/initializer (which may take arguments).</p>

<div class="section" id="svg">6.  SVG  </div>

<precode>
  svg.Element.mk(&lt;markup&gt;);
</precode>
<p>creates an object that inherits from the prototype <cw>svg.Element</cw>, which in turn
inherits from <cw>pj.Object</cw>. Its  content
as an SVG element is as specified by the markup. At this stage, only some of the tags are supported:
<cw>clipPath, circle,  g, line, linearGradient, path, polygon, polyline,  rect, radialGradient,  stop,  text, </cw> and <cw>tspan</cw>.
</p>
<p> Here is an example: </p>

<precode>
var circle = svg.Element.mk('&lt;circle fill="rgb(39, 49, 151)" stroke="black" stroke-width="1" r="5" /&gt;');
</precode>

<p>Each <cw>svg.Element</cw> may have an associated coordinate system/transform. The methods <cw>__getTransform</cw>, and <cw>__setTransform</cw> access this,
and operations such as <cw>__moveto</cw>
affect it.  See the <a href="#API">API section</a> for details. As in SVG, the transforms represent coordinate systems relative to parents. The root of the
visible tree is held in <cw>pj.root</cw>.</p>

<p>An <cw>svg.Element</cw> is displayed by construction of an associated element in the SVG Dom. Each <cw>svg.Element</cw> has
a standard list  of properties that are transferred from the item to the Dom, by setting attributes in the Dom from the values of the properties of the item
of the same name. This default behavior can be extended by defining the <cw>__setDomAttributesProperty</cw> method,
which, if present, will be called after the standard transfer of properties.
  Here is its definition for the
<a href="http://127.0.0.1:3000/code.html?source=/shape/rectangle.js">rectangle component</a>, which assures that the rectangle is centered
on the origin in its own coordinate system (this positioning is the convention for all shapes):</p>

<precode>
  
item.__setDomAttributes =  function (element) {
  element.setAttribute('x',-0.5*this.width);
  element.setAttribute('y',-0.5*this.height);
}

</precode>

<p>

<div class="section" id="conventions">7.  Naming Conventions</div>
<p>Developers  perform their work by defining new properties and methods for <cw>pj.Object, pj.Array,</cw> and
<cw>pj.svg.Element</cw>.
Thus, the issue arises of avoiding name collisions with methods on these types that PrototypeJungle
itself defines. A primitive scheme addresses this issue: except for a very small collection of basic methods,
PrototypeJungle uses names that start with a double underbar (__). So, name collisions
can be avoided if developers never use double-underbar prefixes for the  properties and methods that they
introduce for their own purposes.
Of course, the
few basic methods should not be trampled on either, but it is a very short list, namely:
<cw>instantiate, mk, name, parent, remove,</cw> and <cw>set</cw>. <a href="#update"> <cw>update</cw></a> is also reserved for a  special purpose (see the next section).
Finally, when an item is created via <cw>svg.Element.mk(&lt;markup&gt;)</cw>,
the SVG attributes from the markup are imported as properties of the item without changing names (that is, no underbars are introduced).</p>

<p>It is not quite right to call the double underbarred symbols <i>private</i>, since, as you will see,
several of them
(eg <cw>__setExtent</cw> to take a random example) have designated public purposes. </p>

<div class="section" id="update">8.  The Update Method</div>

<p> In the <a href="#quickStart">introductory example</a>, an item was simply constructed and displayed. There was no support for reconfiguration of the item based on
 varying parameters imposed from above by its use as a component, or by interactivity (see the <a href="#controllers">next section</a>). Implementing parametric
reconfiguration is accomplished by defining an update method for the item. Consider the following extension of the introductory
example:</p>

<precode>
  item.update = function () {
    var p1=this.p1,p2 = this.p2;
    this.circle1.__moveto(p1);
    this.circle2.__moveto(p2);
    this.arrow1.setEnds(p1,p2);
    this.arrow2.setEnds(p2,p1);
    this.arrow1.update();
    this.arrow2.update();
  }
</precode>

<p>
This method moves <cw>circle1</cw> and <cw>circle2</cw> to <cw>this.p1</cw> and <cw>this.p2</cw>, respectively, and then causes the arrows to point at the circles.
Updates are triggered automatically at load time, and in any circumstance of change.
By "a circumstance of change" is meant one in which the implementation detects a potentially relevant event (eg editing properties in the right panel).
Update methods, can, of course, be invoked explicitly.  Each update method is responsible for triggering updates of its descendants
(the automatic updater traverses the tree looking for update methods, but when such a method is found, it does not descend the tree further).
</p>


<p>Interaction utilizing the above-mentioned update method can be seen at work at
<a href="/edit.html?source=/example/simpleDiagramInteractive.js">https://prototypejungle.org/edit.html?source=/example/simpleDiagramInteractive.js</a>.
Try dragging the circles.</p>

<div class="section" id="controllers">9.  Controllers </div>
<p>Notice that when you select a circle in the  <a href="/edit.html?source=/diagram/cayleyD3.js">Cayley diagram</a>,
a box with draggable handles appears
which allows you to resize that circle or its prototype.
Also, when you select one of the arrows in this diagram, handles appear that allow
modification of the size of the arrow head, and the curvature of the arrow (again available for both instance and prototype).
These are dubbed "controllers",  and can be implemented for any item. They come in two varieties "resizer"
and "custom".  To implement a resizer, two methods, <cw>item.__getExtent()</cw>  returning a <cw>geom:Point</cw> , and
<cw>item.__setExtent(extent)</cw> ,
where extent is a <cw>geom:Point</cw> , should be defined, and <cw>item.__adjustable</cw>  should be set to true.  The input to <cw>__setExtent</cw> 
represents the new extent that the  item should take on.
If these steps are taken,  a resizing box with its
handles will appear in the UI whenever the item or its instances are selected.
See the <a href="/code.html?source=/shape/circle.js">circle code</a> for a simple example.
</p>

  
<p>To define a custom control, the two methods needed are <cw>__controlPoints()</cw>, and <cw>__updateControlPoint(index,pos)</cw>.
<cw>__controlPoints</cw> should return a <cw>pj.Array</cw> of <cw>geom.Point</cw> (s). When the item is selected, yellow handles will appear
at the  positions returned by <cw>__controlPoints</cw> (the points should be given relative to the item's own origin). Then, when the handles are dragged,
 <cw>__updateControlPoint(index,pos)</cw> is called at each moment of dragging, with index set to the index
of the point which generated the handle being dragged, and <cw>pos</cw>  to its new position. It is the responsibility of
<cw>__updateControlPoint</cw> to update and redisplay the item as appropriate given the new  handle position.
The <a href="/code.html?source=/shape/arrow.js">arrow</a>
provides an example.</p>
<p>If all four methods are defined, and <cw>__adjustable</cw> is set, the item will be
displayed with both a resize box, and the custom handles.
</p>


<div class="section" id="drag">10.  Diagrams</div>
<p>
  A diagram is an item with three kinds of special behavior. As example, consider the tree. You can drag a tree
  into the viewing panel from the insert panel (under diagrams). Alternatively, have a look here.
</p>
<p> These are the special behaviors, illustrated by trees:</p>
<p>
   1) <b> Dragging</b> a node of the tree drags its subtree along with it, and 
the right relationships between edges (arrows) and nodes (circles) are maintained.
</p>
<p>
2) If a node is <b>deleted</b> it takes its subtree with it.</p>
<p> 3) When any part of the tree is selected, the <b>action panel</b> on the left side of the screen
is extended with the items: add child,
connect and reposition subtree. Try adding a few children, dragging them around, and then reposition some subtrees.
(Repositioning 
will bring the depending subtree into a standard configuation, overriding previous drags).</p>
<p>
These behaviors are defined in the code for the tree item, not in the implementation of PrototypeJungle.
Consequently, new kinds of diagrams with their own behaviors can be added  by any programmer.
</p>

<p>
Any item can be defined as a diagram, via
</p>
<precode>
diag.__diagram = true;
</precode>
<p>
  The special behaviors are specified as follows:
</p>
<p>
1) The two methods
</p>
<precode>
diag.__dragStart

item.__dragStep
</precode>

<p>
define the custom dragging behavior of diag's descendants.
</p>
<p>
For example, here are the methods for trees:
</p>

<precode>
item.__dragStart = function (refpoint) {
  this.computeRelativePositions();
}


item.__dragStep = function (vertex,pos) {
 var localPos = geom.toLocalCoords(this,pos);
 vertex.__moveto(localPos);
 this.positionvertices(vertex);
 this.update();
}
</precode>

<p>
When a node x in the tree is dragged, the __dragStart method of the containing diagram (in this
case the tree) is called at the beginning of the drag. Subsequently at each small step of dragging,
the __dragStep method is called with two arguments: x, and its new position. In the tree case, __dragStep is so
defined that  the subtree beneath the dragged node is moved along with it - this is what positionvertices does.
</p>
<p>
2) diag.__delete works in a similar fashion. If __delete is defined for the diagram,
then when any item x in the diagram is deleted, this method is called with x as argument. In the tree case,
the subtree depending from x is deleted (as you will see from the code).
</p>
<p>
3) The additional menu items for the left panel are defined as follows for the tree:
</p>
<precode>
item.__actions = function (item) {
  if (item.__role === 'vertex') {
    return [{title:'add child',action:'addDescendant'},{title:'connect',action:'connectAction'},
                            {title:'Reposition Subtree',action:'reposition'}];
  }
}
</precode>
<p>
As you can see, __actions returns a list of objects each with title and method name. When an item in the diagram
is selected, titles appear in the left panel. Each associated method name should be defined as indicated by the
example:
</p>
<precode>
diag.addDescendant = function (diagram,vertex) {
</precode>

<p>A concise example is provided by the
<a href="/code.html?source=/example/simpleDiagramInteractive.js">interactive version</a> of the simple diagram.
</p>

<div class="section" id="drag">10.  Roles and The Background Graph</div>

<p>When PrototypeJungle is initialized without source, there is a diagram already present, a graph (aka network)
which supports nodes connected by edges. Initially the graph has no content, but as shapes  are dragged into the
viewing window,
they are added to the graph. This is how the functionality described in the "Connecting with arrows and lines"
section of the tutorial is supported.</p>

<p><b>Roles</b>In most diagrams, the visible entities play varying roles. For example in graphs and trees,
some shapes
play the role of nodes, and some of edges. The role can be assigned directly in code via:</p>

<precode>
item.__role = &lt;roleName&gt;
</precode>
<p>
In catalogs, items may be supplied with several possible roles (comma separated). Generally, each kind of diagram
will have its own set of roles that it assigns to its elements. When a shape is dragged into a diagram, the
code which implements the diagram looks at the roles assigned in the catalog, and chooses one which is relevant
to that sort of diagram, if any. At the moment, the drag-into-diagram functionality is implemented only for the
background graph, and each item in the catalog has at most one role (either "vertex" or "edge").
</p>

  
<div class="section" id="files">11. Replacement and transferred properties</div>
<p>When replacing  via "replace" or "replace prototype" in the top bar,  only shapes whose role appears in the
roles assigned in the catalog are presented as possibilities (via a highlight of the candidate shape as
the mouse rolls over it)</p>
<p>For any item, item.__transferredProperties, if present, tells what properties to transfer from the shape to its
replacement.</p>
<p> A diagram might define diag.__diagramTransferredProperties.  When a shape is replaced within the diagram,
these properties are transferred as well when elements within the diagram are replaced
(generally these are properties which carry diagramatic aspects of the shape in question - such as connections
in graphs).</p>

<div class="section" id="files">11. Files</div>

<p>PrototypeJungle exhibits a conventional sort of file system, implemented in the cloud via
<a href="https://firebase.google.com/">Firebase</a>. Filenames typically
look like this: <cw>(userName)/test/arcArrow.js</cw>.  PrototypeJungle utilizes
the file extensions .js .svg, .catalog, and .item

A .item file is of the
sort that arises from serializing an item  - typically an item that has been built or adjusted in the UI.
Catalogs are explained 

<a href="#catalogs">below</a>.
</p>

<div class="section" id="licensing">12. MIT License</div>

<p> PrototypeJungle aims to support open collaboration.
All of the code (and other content) at  PrototypeJungle, including its implementation, the catalogs of elements and diagrams, and the code that you post at the
site,
is covered by the <a href="https://opensource.org/licenses/MIT">MIT license</a>, which means that the code can be freely shared and modified. See our
<a href="/doc/toc.html">terms and conditions</a> for details.
We encourage you to include comments in your code of the form:</p>
<precode>
// contributed by:&lt;name&gt; user id: &lt;userId&gt;
</precode>
<p>
if you wrote the original version, or</p>
<precode>
// with contributions by &lt;name&gt; user id: &lt;userId&gt;
</precode>
<p>
if you are extending or modifying existing code, and to retain these comments from code that you modify.
</p>


<div class="section" id="catalogs">13. Catalogs</div>

<p> A PrototypeJungle catalog is a visual list of items. When you click on "insert" in the structure editor, a catalog
is displayed in the right hand panel, from which is selected the item to insert. Any PrototypeJungle user can
create catalogs via the catalog editor. Here is the catalog editor opened on the default catalog:</p>
<p style="font-size:11pt">
<a href = "/catalogEdit.html?source=(sys)/global.catalog">https://prototypejungle.org/catalogEdit.html?source=(sys)/global.catalog</a>
</p>
<p>
A catalog entry associates a .js  file with a .svg file. The .js file contains the definition of the item,
and the .svg  file provides the associated image for the catalog.
Entries are grouped by tab. Other information associated with an entry:</p>
<ul>
<li><b>tab</b>  The tab within which the entry will appear</li>
<li><b>title</b> (optional) Text that will appear with the entry</li>
<li><b>id</b> Inserted items will be assigned names of the form id&lt;number&gt;</li>
<li><b>scale</b> The svg image is scaled by this factor (should be &lt;= 1)</li>
<li><b>svg</b> The image for the entry</li>
<li><b>file</b> The definition for the entry</li>
</ul>

<p>
Catalogs other than the default are invoked with the GET arguments <cw>catalog=</cw> or
<cw>catalogExtension=</cw> . In the former case, the catalog appearing in the UI is replaced, and in the latter case, the
default catalog is extended by the entries  in the specified catalog. For example:</p>
<p style="font-size:11pt">
<a href = "/edit.html?catalog=(uX4nHHSirBX1ScCSttzciogkxQ92)/catalog/example.catalog">https://prototypejungle.org/edit.html?catalog=(uX4nHHSirBX1ScCSttzciogkxQ92)/catalog/example.catalog</a>
</p>
<p>
will open the structure editor in  a mode where insertions are chosen from the given catalog. The catalog can be viewed at</p>
<p style="font-size:11pt">
<a href = "/catalogEdit.html?source=(uX4nHHSirBX1ScCSttzciogkxQ92)/catalog/example.catalog">https://prototypejungle.org/catalogEdit.html?source=(uX4nHHSirBX1ScCSttzciogkxQ92)/catalog/example.catalog</a>
</p>
<p>The code editor also uses catalogs, and
respects the same GET arguments as the structure editor (that is, <cw>catalog=</cw> and <cw>catalogExtension=</cw>).
</p>
<div class="section" id="visibility">14. Controlling Access to Properties</div>

<p> When an item is selected in the structure editor, its properties and those of its prototype are displayed in the right-hand panel. The default
is that <i>all</i> properties appear, but  some of the properties might be irrelevant to the user. Consider the basic
<a href="/edit.html?source=/shape/arrow.js">arrow</a> (click on the arrow to see its visible properties).
The <a href="/code.html?source=/shape/arrow.js">code</a> which implements it contains this line near the bottom:

<pre><code>
ui.hide(item,['head','shaft','end0','end1','direction','labelText','includeEndControls']);
</precode>

<p>The subsequent line:</p>

<pre  id="__setFieldType"><code>
item.__setFieldType('solidHead','boolean');
</precode>
<p>
causes the <cw>solidHead</cw> property to be displayed with a true/false selection box.
Similarly, in the  implementation of the <a href="/edit.html?source=/shape/shadedCircle.js">shadedCircle</a> , the line</p>

<pre id="setFieldType"> <code>
item.__setFieldType('outerFill','svg.Rgb');
</precode>
<p>
causes the <cw>outerFill</cw> property to be displayed with the <a href="https://bgrins.github.io/spectrum/">Spectrum color picker</a>. By default,this chooser is deployed for
all fields named <cw>fill</cw> or <cw>stroke</cw>.</p>

<p>By default, the values of properties are editable in the property panel. But with</p>


<pre id="uifreeze"><code>
ui.freeze(item,[property1,property2,...property<sup style="font-size:8pt">n</sup>]);
</precode>

<p> the given properties are presented in non-editable form.</p>


<div class="section" id="API">15. API </div>
<!--<p>This section supplies a short list of the stable calls  in this proof-of-concept. </p>-->

<p><i>(Partial listing - more to come)</i></p>
<p>Calls are given in the form <code>f(arg1:type1,arg2:type2...)</code> where types are: <code>string, number, Node (Array or Object) </code> or <code>any</code>. When a call
is described in more detail elsewhere in this document, a <a href="">link</a> is supplied.</p>

<div class="apiSection">Core</div>

<div class="apiCall">
  <div class="apiCallNm">pj.Object.mk()</div><div class="apiCallDf">Constructor for pj.Object</div>
</div>
<div class="apiCall">
  <div class="apiCallNm">pj.Array.mk()</div>
  <div class="apiCallDf">Constructor for pj.Array</div>
</div>
<!--<div class="apiCall">
  <div class="apiCallNm">pj.Object.addListener( nm:string; fn:function)</div>
 <div class="apiCallDf">Used in PrototypeJungle's simple event system. Documention pending.</div>
</div>-->
<div class="apiCall">
  <div class="apiCallNm">pj.Object.set(nm:string,vl:any)</div>
 <div class="apiCallDf">Assign vl as the child of <code>this</code></div>
</div>
<div class="apiCall">
  <div class="apiCallNm">pj.Object.remove(vl:Node)</div>
 <div class="apiCallDf">Remove <code>this</code> from the tree in which it appears.</div>
</div>
<div class="apiCall">
  <div class="apiCallNm">pj.Object.instantiate()</div>
 <div class="apiCallDf"><a href="#instantiation">Link</a>.</div>
</div>

<div class="apiCall">
  <div class="apiCallNm">pj.stringify(v:node)</div>
 <div class="apiCallDf"><a href="#serialization">Link</a>.</div>
</div>


<div class="apiCall">

 <div class="apiCallNm">pj.Object.__setFieldType(type:string)</div><div class="apiCallDf"><a href="#setFieldType">Link</a></div>
</div>
<!--
<div class="apiCall">
  <div class="apiCallNm">pj.Object.setData()</div>
 <div class="apiCallDf"><a href="#setData">Link</a>.</div>
</div>
<div class="apiCall">
  <div class="apiCallNm">pj.Object.outerUpdate()</div>
 <div class="apiCallDf"> Documention pending.</div>
</div>-->
<div class="apiCall">
  <div class="apiCallNm">pj.lift(o)</div>
 <div class="apiCallDf"><a href="#lift">Link</a>.</div>
</div>

<div class="apiCall">
  <div class="apiCallNm">pj.treeProperties( nd:Node, includeLeaves:boolean)</div>
 <div class="apiCallDf">Returns an array of the direct properties of <cw>nd</span> which are edges of the prototype tree.
 </div>
</div>

<div class="apiCall">
  <div class="apiCallNm">pj.declareComputed(nd:Object)</div>
 <div class="apiCallDf">Declare that <cw>nd</span> is generated by computation within an update method. The effect of this
is to delete  <cw>nd</span>  when the item is saved; updates are always run as the part of the restore process,
so  <cw>nd</span>  will be recomputed on restore. Computed content can be modified in the structure editor,  and these modifications will be retained through subsequent
updates, saves, and restores. The implementation keeps track of modifications, 
and, whenever an update is done, reapplies the modifications to the updated state. </div>
</div>

<div class="apiCall">
  <div class="apiCallNm">pj.Object.__setData(data:pj.Array)</div>
 <div class="apiCallDf">This is a simple utility for <a href="#spreads">spreads</a>. Its implementation is just:
 <cw>{this.__data=data;this.update();}</cw>
 </div>
</div>


<div id = "apiGeom" class="apiSection">geom</div>

<div class="apiCall">
  <div class="apiCallNm">geom.Point.mk(x:number,y:number):<br/>geom.Point</div><div class="apiCallDf">Constructor for geom.Point, with properties x and y. If x and y are omitted, 0,0 are used.</div>
</div>


<div class="apiCall">
  <div class="apiCallNm">geom.Point.plus(p:geom.Point):<br/>geom.Point</div><div class="apiCallDf">Adds point p to this (vector addition)</div>
</div>


<div class="apiCall">
  <div class="apiCallNm">geom.Point.minus():geom.Point</div><div class="apiCallDf"><span class='codeWord'> = geom.Point.mk(-this.x,-this.y)</span></div>
</div>

<div class="apiCall">
  <div class="apiCallNm">geom.Point.difference(p:geom.Point):<br/>geom.Point</div><div class="apiCallDf"><span class='codeWord'> = this.plus(p.minus())</span></div>
</div>


<div class="apiCall">
  <div class="apiCallNm">geom.Point.times(v:number):geom.Point</div><div class="apiCallDf">Scales the point by v</div>
</div>


<div class="apiCall">
  <div class="apiCallNm">geom.toPoint(v:any):geom.Point</div><div class="apiCallDf">Creates a <cw>geom.Point</cw>  from several kinds of input. If <cw>v</cw>
  is an array <cw>[a,b]</cw> it returns a point with coordinates <cw>{x:a,y:b}</cw>; if <cw>v</cw> is a number, a point  with coordinates
  <cw>{x:v,y:0}</cw>,
  if v is a <cw>geom.Point</cw>, a copy of the point. <br/><cw>geom.toPoint()</cw> returns the point with coordinates <cw>{x:0,y:0}.</cw> </div>
</div>


<div class="apiCall">
  <div class="apiCallNm">geom.Rectangle.mk(corner:geom.Point,<br/> extent:geom.Point):geom.Rectangle</div><div class="apiCallDf">Constructor for geom.Rectangle, with properties corner and extent. For example <code>geom.Rectangle.mk(geom.Point.mk(10,20),geom.Point.mk(5,5))</code> has
  (10,20) as its upper-left corner, and (15,25) as its lower-right corner.</div>
</div>



<div class="apiCall">
  <div class="apiCallNm">geom.Transform.mk(<br/>translation:geom.Point,<br/> scale:number,<br/>rotation:number):<br/>
  geom.Transform</div><div class="apiCallDf">
  Constructor for geom.Transform, with properties translation, scale, and rotation. Rotation is in radians. All arguments are
  optional, defaulting to geom.Point.mk(0,0), 1, and 0, respectively.</div>
</div>

<div class="apiSection">svg</div>



<div class="apiCall">
  <div class="apiCallNm">svg.Element.mk(s:string)</div><div class="apiCallDf">Constructor for svg Elements. s is markup.</div>
</div>

<!--

<div class="apiCall">
  <div class="apiCallNm">svg.Element.bringToFront()</div><div class="apiCallDf">Transfers the element so that it is
  the last in the child list of its parent. This has the effect of displaying the element in front of its siblings.</div>
</div>
-->

<div class="apiCall">
  <div class="apiCallNm">svg.Element.__hide()</div><div class="apiCallDf">Self-explanatory.</div>
</div>


<div class="apiCall">
  <div class="apiCallNm">svg.Element.__show()</div><div class="apiCallDf">If an element has been hidden, change its status to "visible"</div>
</div>




<div class="apiCall">
  <div class="apiCallNm">svg.Element.__draw()</div><div class="apiCallDf">Refresh this element. Changes to the PrototypeJungle
  data for an element (and its descendents) are transferred to the svg model. Adding an element to the PrototypeJungle tree
  is not reflected </div>
</div>



<!--
<div class="apiCall">
  <div class="apiCallNm">svg.Root.mk(s:DomElement)</div><div class="apiCallDf">Constructor for a root of the svg model (with tag svg). DomElement should be an element on the current page, retrieved eg via document.getElementById("svgDiv"), to which the new
top-level svg element will be added. The content to be displayed should be set as the child named "contents" of this root.</div>
</div>


<div class="apiCall">
  <div class="apiCallNm">svg.Root.fitContents(v:number)</div><div class="apiCallDf">Arrange for the current contents of the
  svg model to appear centered in the viewing div, scaled into a box that is  fraction v of the available area (eg 0.9 if
  you wish at least a 5% boundary around the content.</div>
</div>
-->



<div class="apiCall">
  <div class="apiCallNm">svg.Element.__getTransform():<br/>geom.Transform</div><div class="apiCallDf">Returns the transform of this element.</div>
</div>


<div class="apiCall">
  <div class="apiCallNm">svg.Element.__setTransform(tr:<br/>geom.Transform)</div><div class="apiCallDf">Sets the transform of this element.</div>
</div>

<div class="apiCall">
  <div class="apiCallNm">svg.Element.__getTranslation():<br/>geom.Point</div><div class="apiCallDf">Returns the translation  of the svg transform of this element.</div>
</div>


<div class="apiCall">
  <div class="apiCallNm">svg.Element.__moveto(p:geom.Point)</div><div class="apiCallDf">Move this element to p. That is, set the translation  of the svg transform of this element to p.</div>
</div>


<div class="apiCall">
  <div class="apiCallNm">svg.Element.__getScale():number</div><div class="apiCallDf">Return the scale of the transform of this element.</div>
</div>

<div class="apiCall">
  <div class="apiCallNm">svg.Element.__setScale(s:number)</div><div class="apiCallDf">Set the scale 
   of the svg transform of this element to s.</div>
</div>






<div class="apiCall">
  <div class="apiCallNm">svg.Element.__bounds(rt:svg.Element):<br/>geom.Rectangle</div><div class="apiCallDf">Return the bounds
  of the given Element (and its descendants).  rt is optional. If
  rt is present, it should be an ancestor of this Element, and the bounds are given relative to rt's coordinate system. If
  rt is absent, bounds are given in the Element's own coordinate system.</div>
</div>


<div class="apiSection">ui</div>

<p>These calls control how property values are displayed in the structure editor.
 </p>


<div class="apiCall">
  <div class="apiCallNm">ui.hide(nd:Node,props:array of string)</div><div class="apiCallDf"> <a href="#visibility">Link</a></div>
</div>

<div class="apiCall">

 <div class="apiCallNm">ui.freeze(nd:Node,props:array of string)</div><div class="apiCallDf"> <a href="#uifreeze">Link</a></div>
</div>



<!--
<div class="apiCall">
  <div class="apiCallNm">ui.watch(nd:Node,props:array of string)</div><div class="apiCallDf">When any of the specified 
  properties of the specified node are modified in the inspector, run an update on the top level. </div>
</div>


<div class="apiCall">
  <div class="apiCallNm">ui.setNote(nd:Node,
  prop:string,note:string)</div><div class="apiCallDf">This supports a simple documentation scheme. It associates the given
  note with property prop of nd. In the inspector, prop will appear with a little "?" which, when clicked, will pop the note.
  </div>
</div>
-->


<div class="apiCall">


</div>



<div class="section" id="spreads">16. Spreads</div>

<p>Spreads are an aid to implementing diagrams in which a sequence of items is generated from  data,  with
one item per datum. Such items are conventionally called "marks" in infographic applications. An example is the
<a href="/edit.html?source=/forCatalog/graph.js">graph diagram</a>, in which
the incoming data consists of vertices and edges. Circles are generated for the former, and arrows for the latter. Spreads are not a core
feature of PrototypeJungle  but rather a coding assist for certain kinds of applications.</p>

<p>
A spread is constructed with:</p>
<precode>
pj.Spread.mk(prototype);
</precode>
<p>
The data associated
with a spread contains a sequence of individual data entities (eg numbers or points). The spread update method instantiates its prototype once for each
datum. Then a user-supplied method, <cw>bind</cw> adjusts each instantiation as appropriate for its datum.
  (That is, each spread has its own method for binding, but the update method is common to all).
In a graph diagram, the vertices and edges are represented as spreads.
The data  for the vertices
is a sequence of labeled positions, and the data for the edges is a sequence of to-from designations. See this
<a href="/repo1/data/sampleGraph.js">sample data file</a> - a require of the above mentioned
<a href="/edit.html?source=/forCatalog/graph.js">diagram</a>.</p>

<p> Here is the relevant code  in <a href="/repo1/diagram/graph.js">graph.js</a> for the spread of vertices:</p>

<precode>
  
item.set('vertices',pj.Spread.mk(item.circleP));
  
item.vertices.bind = function () {
  var data = this.__data;
  var n = data.length;
  for (var i=0;i&lt;n;i++) {
    var circle =  this.selectMark(i);
    circle.vertexId = data[i].id;
    circle.update();
    circle.__moveto(geom.toPoint(data[i].position));
  }
}
 
</precode>

<p>The update method for spreads assumes that its data (a <cw>pj.Array</cw>) has been placed in its <cw>__data</cw> field.  Note that bind utilizes the
spread method <cw>selectMark(n)</cw> to select the nth  instantiation of the spread's prototype.</p>


<div class="section" id="share">17. Sharing Your Work</div>

<p>If you'd like to have a catalog listed in a public directory (forthcoming), give it the name "public.catalog" at top level.
Its listing will allow public use of its elements, and public access to the underlying code.</p>

<p>If you'd like to contribute one or more elements  to PrototypeJungle's
<a href = "/catalogEdit.html?source=(sys)/global.catalog">global catalog</a>, create a catalog of them 
under the name "forGlobal.catalog", and send an email about this to prototypejungle@gmail.com mentioning your user id
(from your accounts page). 
</p>

<p style="padding-bottom:30px">
All contributions (whether at the level of public.catalog or forGlobal.catalog)
will be credited using the name and profile link that you have entered on your
account page.
</p>




{{endplate}}