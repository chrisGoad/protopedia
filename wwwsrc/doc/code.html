{{boilerplate}}
<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/2.1.0/jquery.min.js"></script>

<script>
var documentReady = 0;
var initPage = function () {

    $('#openTreeDetails').click(function () {
        $('#treeDetails').show();
    });
     $('#closeTreeDetails').click(function () {
        $('#treeDetails').hide();
    });
       $('#openInstantiateDetails').click(function () {
        $('#instantiateDetails').show();
    });
    $('#closeInstantiateDetails').click(function () {
        $('#instantiateDetails').hide();
    });
}


$('document').ready(function () {
  documentReady = 1;
  initPage();
});
</script>



  
<div class="pageTitle">Coding Guide</div>
<p> PrototypeJungle users can code their own visual elements and diagrams via the code editor, and assemble catalogs of these
new elements via the catalog
editor. Subsequently, such elements and diagrams are available for use in PrototypeJungle's UI, where no coding is required. In addition, the
core technology is openly available under the MIT Licence for use in any application. This document provides the information needed for both
activities.</p>

<p>
Sections 3 - 5  describe how to work with <a href="/doc/tech.html">deep prototypes</a> ("deep" as in hierarchical),
the material from which all PrototypeJungle elements are made.<!--
This is a general purpose
JavaScript component technology hosted at prototypejungle.org. Deep prototypes are the material from which all PrototypeJungle elements are made.-->
  The remaining sections concern  construction of and interaction with 2d shapes implemented by way  of
<a href="https://developer.mozilla.org/en-US/docs/Web/SVG">SVG</a>.
</p>

<div class="tableOfContents"> 
    <div class="contentsLine"><a href="#quickStart">1. Quick Start</a></div>
   <div class="contentsLine"><a href="#codeStructure">2. Code Structure</a></div>
     <div class="contentsLine"><a href="#trees">3. Trees</a></div>
      <div class="contentsLine"><a href="#instantiation">4. Instantiation and Serialization</a></div>
   <div class="contentsLine"><a href="#nonews">5. No news</a></div>  
  <div class="contentsLine"><a href="#svg">6. SVG</a></div>
     <div class="contentsLine"><a href="#conventions">7. Naming Conventions</a></div>

   <div class="contentsLine"><a href="#update">8. The Update Method</a></div>
    <div class="contentsLine"><a href="#controllers">9. Controllers</a></div>
       <div class="contentsLine"><a href="#drag">10. Dragging and Cloning</a></div>
       <div class="contentsLine"><a href="#files">11. Files</a></div>
       <div class="contentsLine"><a href="#licensing">12. Licensing Status of Code</a></div>
        <div class="contentsLine"><a href="#catalogs">13. Catalogs</a></div>
        <div class="contentsLine"><a href="#visibility">14. Controlling Access to Properties</a></div>
        <div class="contentsLine"><a href="#API">15. API</a></div>
                 <div class="contentsLine"><a href="#spreads">16. Spreads</a></div>



</div>

<div class="section" id="quickStart">1. Quick Start </div>
<p style="margin-bottom:20px"> Consider this
simple diagram</p>
 <img id="diagram" src="https://firebasestorage.googleapis.com/v0/b/project-5150272850535855811.appspot.com/o/twitter%3A14822695%2Fexample%2Fsimple_diagram.svg?alt=media&token=6b5f2ce9-5097-4872-9b17-b77515cd8801"
      style="border:thin black solid;cursor:pointer"  width="200" />
<p> which  was produced by the following code:<!-- (it could also have been built without coding in the editor):-->
</p>

<precode>
pj.require('/shape/arcArrow.js',function (arrowPP) {
  var geom = pj.geom;
  var svg = pj.svg;
  var item = svg.Element.mk('&lt;g/&gt;');// the root of the diagram we are assembling
  item.p1 = geom.Point.mk(0,0);
  item.p2 = geom.Point.mk(100,0);
  // the circle prototype
  item.set('circleP',svg.Element.mk(
   '&lt;circle fill="rgb(39, 49, 151)" stroke="black" stroke-width="1" r="5" /&gt;').__hide());
  // instantiate it twice
  item.set('circle1',item.circleP.instantiate()).__show();
  item.set('circle2',item.circleP.instantiate()).__show();
  item.circle1.__moveto(item.p1);
  item.circle2.__moveto(item.p2);
  // now the arrows 
  item.set('arrowP',arrowPP.instantiate()).__hide();
   // set some parameters of the arrow prototype
  item.arrowP.stroke = 'orange';
  item.arrowP.radius = 1; // radius of the arc as a multiple of arrow length
  item.arrowP.headGap = 8;
  item.arrowP.tailGap = 8;
  item.arrowP.solidHead = false;
  // instantiate it twice
  item.set('arrow1',item.arrowP.instantiate()).__show();
  item.set('arrow2',item.arrowP.instantiate()).__show();
  item.arrow1.setEnds(item.p1,item.p2);
  item.arrow2.setEnds(item.p2,item.p1);
  return item;
});

</precode>
<p>
<a href="/edit.html?source=/example/simpleDiagram.js">
  https://prototypejungle.org/edit.html?source=/example/simpleDiagram.js
</a> displays the diagram in the editor, where its structure 
is made visible. The editor allows
interactive modification of  parameters, in many cases via  click and drag (try it). If you're logged in, the results of
modifications can be saved. The editor is explained <a href="/edit.html?source=/diagram/cayleyD3.js&intro=intro">here</a>. </p>

<p> You can also view the diagram in the code editor, where you can experiment with code changes (however, if you wish to save changes you
will need to sign in and save the code to a file of your own). Here's the URL: <a href="/code.html?source=/example/simpleDiagram.js">
  https://prototypejungle.org/code.html?source=/example/simpleDiagram.js
</a> 
 </p>
<p>Note: Browser debuggers (eg <a href="https://developer.chrome.com/devtools">Chrome's DevTools</a>) work well with the code editor. </p>
  <p> Let's walk through the code:</p>
  <precode>
    pj.require('/shape/arcArrow.js',function (errorMessage,arrowPP) {
</precode>
  <p>
<i><b>pj</b></i>: The PrototypeJungle implementation is installed under one global variable,  <cw>prototypeJungle</cw>.
A shorter synonym for that global, <cw>pj</span>, is also available. If you need <cw>pj</span> for other purposes,
it can be freed by calling <cw>prototypeJungle.noConflict()</span>
(this is analogous to <a href="https://api.jquery.com/jquery.noconflict/">jQuery.noConflict()</a>, which frees up $). 
</p>

<p> To continue:
 <cw>
pj.require('/shape/arcArrow.js',function (arrowPP) { ...
 </span>
 binds the variable <cw>arrowPP</span> to the component defined in <cw>'/shape/arcArrow.js'</span>. More generally, consider:
 </p>

<precode>
     pj.require(file1,file2,...,file<sup style="font-size:8pt">n</sup>,function (var1,var2,...,var<sup style="font-size:8pt">n</sup>) { ...});
 </precode>


<p>
Each variable <cw>var<sup style="font-size:8pt">k</sup></span> is bound to the component defined by the corresponding file <cw>file<sup style="font-size:8pt">k</sup></span>.
</p>
<precode>
    var item = svg.Element.mk('&lt;g/&gt;');// the root of the diagram we are assembling
</precode>

 

<p><cw>pj.svg.Element.mk</span> creates a deep prototype from
<a href="https://developer.mozilla.org/en-US/docs/Web/SVG">SVG</a> markup.
In what follows, deep prototypes will be referred to as "items".</p>

<precode>
    item.p1 = geom.Point.mk(0,0);
    item.p2 = geom.Point.mk(100,0);
</precode>

<p> <cw>geom.Points</cw> are items too. </p>
<p>The prototype for the circles is defined by:</p>
<precode>
    item.set('circleP',svg.Element.mk(
       '&lt;circle fill="rgb(39, 49, 151)" stroke="black" stroke-width="2" r="5"/&gt;').__hide());
</precode>


<p>For any <cw>item</span>, </p>

<precode>
    item.set('name',ch);
</precode>

<p>assigns <cw>ch</span> as the child of <cw>item</span>
with the given <cw>name</cw>,  so that <cw>item.name === ch</span>. Items are always trees, not graphs, in their own-property aspect.
Thus, for no other <cw>item2</cw> with own property <cw>'prop'</cw> does <cw>item2.prop === ch</cw>.</p>
<p>Next:</p>

<precode>
   item.set('circle1',item.circleP.instantiate()).__show();
</precode>

<p>
Instantiate is the fundamental operation in PrototypeJungle:
it  is the analog of <cw>Object.create</span>, but works for trees of arbitrary depth.  As it happens,
circles have depth 1,  but arrows, instantiated a few lines later, are of depth 2.  In the case of,
</p>
<precode>
    item.set('arrow1',item.arrowP.instantiate()).__show();
</precode>

<p>
<cw>arrow1</cw> is, roughly speaking, a tree-wise copy of <cw>arrowP</cw>, but the copying is only applied to internal nodes; atomic properties
are inherited. There are <a href="/doc/tech.html#instantiate">details</a>.
Anyway, via instantiation, we get two circles and two arrows, which are then given the differing properties appearing in the diagram. The unmodified properties are inherited. Instantiation is used at all levels - for comparatively simple components like arrows, but also for complete diagrams.
</p>
<p>But we have skipped ahead a little. <cw>arrowP</cw> was defined by: </p>
<precode>
    item.set('arrowP',item.arrowPP.instantiate()).__hide();
</precode>

<p>There is a reason for instantiating <cw>arrowPP</cw> to <cw>arrowP</cw>, and then <cw>arrowP</cw> to <cw>arrow1</cw> and
<cw>arrow2</cw>, rather than deriving <cw>arrow1</cw>
and <cw>arrow2</cw> directly from <cw>arrowPP</cw>. Namely, <cw>arrowPP</cw>, having come into being via a require,
is an external reference of the item we are building. <cw>arrowP</cw>, on the other hand, is an internal structure.
<cw>arrowPP</cw>'s properties (eg fill or stroke) are not available for modification,whereas <cw>arrowP</cw>'s are.</p>

<!--
<p>
<precode>
    pj.returnValue(undefined,item);
</pre></code>
</p>
<p>
returns item as the value of the component.</p>-->
<p>To complete the explantion of this bit of code:  <cw>__show</cw>, <cw>__hide</cw>, and <cw>__moveto</cw> are methods of
<cw>pj.svg.Element</cw> (the prototype which implements drawable shapes based on svg Elements).
<cw>setEnds</cw> is a method of  the arcArrow prototype, whose implementation can be viewed at
<a href="/code.html?source=/shape/arcArrow.js">https://prototypejungle.org/code.html?source=/shape/arcArrow.js</a>.
</p>
<p>
 Any item may be displayed in the editor or assembled into larger structures via require.
</p>
<!--
<p>

Items can also be displayed outside of the editor, as illustrated in the file
<a href="https://prototypejungle.org/repo1/example/standalone.html">https://prototypejungle.org/repo1/example/standalone.html</a>.
Use your browser's <i>view source</i>  to see how this works.
<a href="https://prototypejungle.org/repo1/example/standalone2.html">https://prototypejungle.org/repo1/example/standalone2.html</a>, is similar
but builds the item inline rather than requiring it from simple_diagram.js.
The second variant is available at
<a href = "https://jsfiddle.net/tasp1umh/">jsfiddle</a></p>
<p>
PrototypeJungle also has a viewer:<br/> <a href="https://prototypejungle.org/view.html?source=https://prototypejungle.org/repo1/example/simple_diagram.js">
https://prototypejungle.org/edit.html?source=https://prototypejungle.org/repo1/example/simple_diagram.js</a>
</p>
-->




<div class="section" id="codeStructure">2. Code Structure </div>

<p>The PrototypeJungle implementation has three levels. First, there  is the core, in which deep prototypes
and their basic operations, including serialization and instantiation, are defined. The second level supports
deep prototypes in the context of 2d graphics. <!--
Protototypes are provided for 2d graphical shapes and their operations, and for sets of infographic marks
with data binding. -->This level of the implementation relies on
<a href="https://developer.mozilla.org/en-US/docs/Web/SVG">SVG</a>. The third level implements the ProtoypeJungle user interfaces found in
the structure editor, the code editor, and the catalog editor.
The first two levels are independent of the PrototypeJungle website, and could be used in any JavaScript application, whereas the third is in various
ways connected to the website (the latter code could be adapted for other situations, though).
</p>


<p>The first two levels are implemented by 
<a href="https://prototypejungle.org/js/core-0.9.3.js">https://prototypejungle.org/js/core-0.9.3.js</a> and
<a href="https://prototypejungle.org/js/dom-0.9.3.js">https://prototypejungle.org/js/dom-0.9.3.js</a>.
There are minimized versions: https://prototypejungle.org/js/core-0.9.3.min.js and https://prototypejungle.org/js/dom-0.9.3.min.js.
Include these lines in applications:</p>

<precode>
&lt;script src="https://prototypejungle.org/js/core.0.9.3.min.js"&gt;&lt;/script&gt;
&lt;script src="https://prototypejungle.org/js/dom-0.9.3.min.js"&gt;&lt;/script&gt;
</precode>

<p>
 All code (organized into smaller files) is at <a href="https://github.com/chrisGoad/prototypejungle/tree/master">GitHub</a>, and is open source under the
MIT License.</p>
<!--
<p> For charts, there is a fourth level of code: the code that implements the charts themselves, and their components
such as axes and legends.  The code for these appears in the current prototype repository: https://prototypejungle.org/repo3/charts, and also at github.
-->


<!--Not much will be said about the editor in this document.-->


<div class="section" id="trees">3. Trees</div>

<p> All deep prototypes (aka "items") are trees: each non-atomic child 
has a unique parent. (Formally, if <cw>parent.prop === child</cw>, and <cw>prop</cw> is an own property of <cw>parent</cw>,
there is no <cw>parent2</cw> with <cw>parent2 !== parent</cw>, and
with <cw>parent2.prop2 === child</cw> for own property <cw>prop2</cw> of <cw>parent2</cw>). 
 The internal nodes in items  inherit from prototypes <cw>pj.Array</cw>
for sequential, zero-based arrays, and <cw>pj.Object</cw>  for objects which are not arrays.  

</p>

<precode>  
pj.Object.mk();
</precode>

<p> creates a  new <cw>Object</span>, and</p> 
<precode>
pj.Array.mk();
</precode>
<p> a new <cw>Array</span>.</p>
<p> 
<precode>
object.set('name',child);
</precode>

<p>assigns <cw>child</span> as a child of 
<cw>object</span> with name <cw>name</span>.
If <cw>child</span> is an Object or Array, this results in setting special properties:
<cw>child.__parent === object</span>, and <cw>child.__name === 'name'</span>.</p>

<p> For an Array,</p>
<precode>
array.push(child);
</precode>

<p>pushes <cw>child</span> onto the end of  <cw>array</span>,
and assigns <cw>array</span> as the parent of <cw>child</span>. That is,
<span class="code">array[array.length-1] === child</span>, and if <cw>child</span> is an Object or Array,
and <span class="code">child.__parent === array</span>. Also, <span class="code">child.__name === array.length-1</span>.
Arrays are always sequential and zero-based.
</p>



<pre id="lift"><code>
pj.lift(obj);
</code></pre>


<p>takes an "ordinary" Javascript tree such as one expressable in JavaScript object notation,
and turns it into the PrototypeJungle kind of tree. 
For example: </p>
<precode>
pj.lift({a:2,b:["a",4]});
</precode>

<p> will produce a Object/Array tree with matching structure.  </p>


<p>Click <span class="clickable" id="openTreeDetails">here</span> for an example of tree construction and manipulation.</p>
<div id="treeDetails" class="techDetails">
<div class="close" id="closeTreeDetails">X</div>



<precode>
var root = pj.Object.mk();
var aa = pj.Object.mk();
var bb = pj.Object.mk();

root.set("a",aa); // adds aa as a child named "a" of root
root.set("b",bb);

// __name and __parent "glue the tree together".
bb.__name;
==>b
bb.__parent === root;
==>true

// let's add some atomic data 
aa.x = 5;  // set is not needed for atomic data or functions
aa.f = function (x) {return x*x;}

// now for an Array
var cc = pj.Array.mk();
bb.set("c",cc);

cc.push(pj.Object.mk().set("z",45));
cc.push(5);

</code>
</pre>
<p>this yields:</p>
<precode>
          --root--
        /          \
       a            b
      / \            \
     x   f            c
    /     \            \
   5    function      [ *, 5]
                       /
                      z
                     /
                    45
   

</code>
</pre>
<p> where * is an Object</p>

<p>
This could also be built with
</p>

<precode> 
var root = pj.lift({a:{x:5},b:{c:[{z:45},5]}})
root.a.f = function (x) {return x*x};
</precode>


<p>There is nothing wrong with having properties of Objects that reference
nodes in the tree  other than children,  as in </p> 

<precode>
a.xx = b; 
</precode>
 
<p>in the above example.Then xx is a cross-tree reference.</p>
<p><i>Restriction on names</i>: names may include only letters, numerals, and the underbar, and may not start with a numeral.</p>
</div>

<div class="section" id="instantiation">4. Instantiation and Serialization</div>
<precode> 
inode = node.instantiate();
</precode>

<p> builds an instantiation of <cw>node</cw>; a tree which has the same structure as <cw>node</cw>, but inherits primitive
data and functions from <cw>node</cw> via prototypical inheritance. (Details
<a href="/doc/tech.html#instantiate">here</a>)</p>
<p id="serialization">Serialization is performed by: 
<precode> 
s = pj.stringify(node);
</precode>

<p> as described <a href="/doc/tech.html#serialize">here</a>.</p>


<div class="section" id="nonews">5. No news</div>
<p> Nodes are constructed with <cw>pj.Object.mk()</span> and <cw>pj.Array.mk()</span>, rather than via the use of a "new".
The definition of the <cw>mk</cw> method for <cw>Object</cw> is:

<precode>
pj.Object.mk = function () {
  return Object.create(pj.Object);
}
</precode>


<p>Recall that <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create">Object.create</a>(X) creates a new object with X as prototype.
</p>


<p><cw>Object</span> is introduced simply with:</p>

<precode>
pj.Object = {};
</precode>

<p>and <cw>Array</span>  with:</p>


<precode>
pj.Array = [];
</precode>

<p>
<cw>pj.Object</span> itself serves as the prototype for instances.  In the more conventional pattern, <cw>pj.Object</span> would be a function, and
the prototype property of that function, not <cw>Object</cw> itself, would be the  prototype for the instances generated via the new operator
(note that if <code>F = function (){}, new F()</code> is equivalent
to <code>Object.create(F.prototype)</code>)
</p>
<p>
The <cw><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new">
function, function.prototype, new</a></span> &nbsp; pattern has been available in JavaScript all along,
whereas the  more direct <cw>Object.create</span> was introduced more recent years (in version 1.8.5 to be exact). PrototypeJungle
employs the newer pattern, not so much for its intrinsic  simplicity (though that's nice), but because this way of doing things has a major
simplifying effect on the entire PrototypeJungle code base. </p>

<p> You will never see a "new" anywhere in the code. The convention is that for prototype  <cw>X</span>, <cw>X.mk</span> is the creator/initializer (which may take arguments).</p>

<div class="section" id="svg">6.  SVG  </div>
<p>We have seen SVG Elements before, as in the line</p>
<precode>
   item.set('circleP',svg.Element.mk(
   '&lt;circle fill="rgb(39, 49, 151)" stroke="black" stroke-width="1" r="5" /&gt;').__hide());
</precode>

<p> in the <a href="#quickStart">quick start</a> section. 
Generally, <cw>svg.Element.mk(markup);</cw> creates an object that inherits from the prototype <cw>svg.Element</cw>, which in turn
inherits from <cw>pj.Object</cw>. Its  content
as an SVG element is as specified by the markup. At this stage, only some of the tags are supported:
<cw>clipPath, circle,  g, line, linearGradient, path, polygon, polyline,  rect, radialGradient,  stop,  text, </cw> and <cw>tspan</cw>.
</p>
<p>Each <cw>svg.Element</cw> may have an associated coordinate system/transform. The methods <cw>__getTransform</cw>, and <cw>__setTransform</cw> access this,
and operations such as <cw>__moveto</cw>
affect it.  See the <a href="#API">API section</a> for details. As in SVG, the transforms represent coordinate systems relative to parents. The root of the
visible tree is held in <cw>pj.root</cw>.</p>

<p>An <cw>svg.Element</cw> is displayed by construction of an associated element in the SVG Dom. Each <cw>svg.Element</cw> has
a standard list  of properties that are transferred from the item to the Dom, by setting attributes in the Dom from the values of the properties of the item
of the same name. This default behavior can be extended by defining the <cw>__setDomAttributesProperty</cw> method,
which, if present, will be called after the standard transfer of properties.
  Here is its definition for the
<a href="http://127.0.0.1:3000/code.html?source=/shape/circle.js">circle component</a>:</p>

<precode>
item.__setDomAttributes = function (element) {
  element.setAttribute('r',0.5*this.dimension); // set the circle's radius to half its dimension
};
</precode>

<p>

<div class="section" id="conventions">7.  Naming Conventions</div>
<p>Developers  perform their work by defining new properties and methods for <cw>pj.Object, pj.Array,</cw> and
<cw>pj.svg.Element</cw>.
Thus, the issue arises of avoiding name collisions with methods on these types that PrototypeJungle
itself defines. A primitive scheme addresses this issue: except for a very small collection of basic methods,
PrototypeJungle uses names that start with a double underbar (__). So, name collisions
can be avoided if developers never use double-underbar prefixes for the  properties and methods that they
introduce for their own purposes.
Of course, the
few basic methods should not be trampled on either, but it is a very short list, namely:
<cw>instantiate, mk, name, parent, remove,</cw> and <cw>set</cw>. <a href="#update"><cw>update</cw></a> is also reserved for a  special purpose (see the next section).
It is not quite right to call the double underbarred symbols <i>private</i>, since, as you will see,
several of them
(eg <cw>__getExtent</cw> to take a random example) have designated public purposes. </p>

<div class="section" id="update">8.  The Update Method</div>

<p> In the <a href="#quickStart">introductory example</a>, an item was simply constructed and displayed. There was no support for reconfiguration of the item based on
 varying parameters imposed from above by its use as a component, or by interactivity (see the <a href="#controllers">next section</a>). Implementing parametric
reconfiguration is accomplished by defining an update method for the item. Consider the following extension of the introductory
example:</p>

<precode>
  item.update = function () {
    var p1=this.p1,p2 = this.p2;
    this.circle1.__moveto(p1);
    this.circle2.__moveto(p2);
    this.arrow1.setEnds(p1,p2);
    this.arrow2.setEnds(p2,p1);
    this.arrow1.update();
    this.arrow2.update();
  }
</precode>

<p>
This method moves <cw>circle1</cw> and <cw>circle2</cw> to <cw>this.p1</cw> and <cw>this.p2</cw>, respectively, and then causes the arrows to point at the circles.
Updates are triggered automatically at load time, and in any circumstance of change.
By "a circumstance of change" is meant one in which the implementation detects a potentially relevant event (eg editing properties in the right panel).
Update methods, can, of course, be invoked explicitly.  Each update method is responsible for triggering updates of its descendants
(the automatic updater traverses the tree looking for update methods, but when such a method is found, it does not descend the tree further).
</p>


<p>Interaction utilizing the above-mentioned update method can be seen at work at
<a href="/edit.html?source=/example/simpleDiagramInteractive.js">https://prototypejungle.org/edit.html?source=/example/simpleDiagramInteractive.js</a>.
Try dragging the circles.</p>

<div class="section" id="controllers">9.  Controllers </div>
<p>Notice that when you select a circle in the  <a href="/edit.html?source=/diagram/cayleyD3.js">Cayley diagram</a>,
a box with draggable handles appears
which allows you to resize that circle or its prototype.
Also, when you select one of the arrows in this diagram, handles appear that allow
modification of the size of the arrow head, and the curvature of the arrow (again available for both instance and prototype).
These are dubbed "controllers",  and can be implemented for any item. They come in two varieties "resizer"
and "custom".  To implement a resizer, two methods, <cw>item.__getExtent()</cw>  returning a <cw>geom:Point</cw> , and
<cw>item.__setExtent(extent)</cw> ,
where extent is a <cw>geom:Point</cw> , should be defined, and <cw>item.__adjustable</cw>  should be set to true.  The input to <cw>__setExtent</cw> 
represents the new extent that the  item should take on.
If these steps are taken,  a resizing box with its
handles will appear in the UI whenever the item or its instances are selected.
See the <a href="/code.html?source=/shape/circle.js">circle code</a> for a simple example.
</p>

  
<p>To define a custom control, the two methods needed are <cw>__controlPoints()</cw>, and <cw>__updateControlPoint(index,pos)</cw>.
<cw>__controlPoints</cw> should return a <cw>pj.Array</cw> of <cw>geom.Point</cw> (s). When the item is selected, yellow handles will appear
at the  positions returned by <cw>__controlPoints</cw> (the points should be given relative to the item's own origin). Then, when the handles are dragged,
 <cw>__updateControlPoint(index,pos)</cw> is called at each moment of dragging, with index set to the index
of the point which generated the handle being dragged, and <cw>pos</cw>  to its new position. It is the responsibility of
<cw>__updateControlPoint</cw> to update and redisplay the item as appropriate given the new  handle position.
The <a href="/code.html?source=/shape/arrow.js">arrow</a>
provides an example.</p>
<p>If all four methods are defined, and <cw>__adjustable</cw> is set, the item will be
displayed with both a resize box, and the custom handles.
</p>

<div class="section" id="drag">10.  Dragging and Cloning</div>
<p>
If <cw>item.__draggable</cw> is set, the item can be dragged.
Sometimes, it is desirable to implement side effects of a drag. For example in the
<a href="/edit.html?source=/diagram/cayleyD3.js">Cayley diagram</a>,  dragging a circle causes
reconfiguration of the graph to maintain the right relationships between edges (arrows) and nodes (circles).
In the code that implements <a href="/code.html?source=/diagram/graph.js">graphs</a>, the following methods are defined:
</p>

<precode>
item.circleP.__dragStart = function (refPoint) {...
</precode>

<p>and</p>

<precode>
item.circleP.__dragStep = function (pos) {...
</precode>

<p>
The <cw>refPoint</cw> is the original position of the circle being dragged, in <cw>pj.root</cw> coordinates, and <cw>pos</cw> is its position at each moment of drag,
in the same coordinates.
</p>
<p>Another, more concise, example is provided by the
<a href="/code.html?source=/example/simpleDiagramInteractive.js">interactive version</a> of the simple diagram.
</p>
<p>
Finally, if <cw>item.__cloneable</cw> is set, cloning for that item and its instances will become available in the user interface (no effort beyond
setting the flag is needed).
</p>



<div class="section" id="files">11. Files</div>

<p>PrototypeJungle exhibits a conventional sort of file system, implemented in the cloud via
<a href="https://firebase.google.com/">Firebase</a>. Filenames typically
look like this: <cw>(uX4nHHSirBX1ScCSttzciogkxQ92)/test/arcArrow.js</cw>. uX4nHHSirBX1ScCSttzciogkxQ92 is a Firebase-assigned
user id. The names of files that you create will start with (yourUserId). Your id is assigned under the hood when you first sign in to
PrototypeJungle. There is one special id <cw>sys</cw> that you will see from time to time. There are four kinds of files: .js, .svg, .catalog, and .item.  The js and svg extensions have their
usual meanings. A .item file is of the
sort that arises from serializing an item  - typically an item that has been built or adjusted in the UI. Catalogs are explained
<a href="#catalogs">below</a>.
</p>

<div class="section" id="licensing">12. MIT License</div>

<p> PrototypeJungle aims to support open collaboration.
All of the code (and other content) at  PrototypeJungle, including its implementation, the catalogs of elements and diagrams, and the code that you post at the
site,
is covered by the <a href="https://opensource.org/licenses/MIT">MIT license</a>, which means that the code can be freely shared and modified. See our
<a href="/doc/toc.html">terms and conditions</a> for details.
We encourage you to include comments in your code of the form:</p>
<precode>
// contributed by:&lt;name&gt; user id: &lt;userId&gt;
</precode>
<p>
if you wrote the original version, or</p>
<precode>
// with contributions by &lt;name&gt; user id: &lt;userId&gt;
</precode>
<p>
if you are extending or modifying existing code, and to retain these comments from code that you modify.
</p>


<div class="section" id="catalogs">13. Catalogs</div>

<p> A PrototypeJungle catalog is a visual list of items. When you click on "insert" in the structure editor, a catalog
is displayed in the right hand panel, from which is selected the item to insert. Any PrototypeJungle user can
create catalogs via the catalog editor. Here is the catalog editor opened on the default catalog:</p>
<p style="font-size:11pt">
<a href = "/catalogEdit.html?source=(sys)/forCatalog/default.catalog">https://prototypejungle.org/catalogEdit.html?source=(sys)/forCatalog/default.catalog</a>
</p>
<p>
A catalog entry associates a .js  file with a .svg file. The .js file contains the definition of the item,
and the .svg  file provides the associated image for the catalog.
Entries are grouped by tab. Other information associated with an entry:</p>
<ul>
<li><b>tab</b>  The tab within which the entry will appear</li>
<li><b>title</b> (optional) Text that will appear with the entry</li>
<li><b>id</b> Inserted items will be assigned names of the form id&lt;number&gt;</li>
<li><b>scale</b> The svg image is scaled by this factor (should be &lt;= 1)</li>
<li><b>resizable</b>  Is the item resizable? (in the sense explained in the controller section)</li>
<li><b>svg</b> The image for the entry</li>
<li><b>file</b> The definition for the entry</li>
</ul>

<p>
Catalogs other than the default are invoked with the GET arguments <cw>catalog=</cw> or
<cw>catalogExtension=</cw> . In the former case, the catalog appearing in the UI is replaced, and in the latter case, the
default catalog is extended by the entries  in the specified catalog. For example:</p>
<p style="font-size:11pt">
<a href = "/edit.html?catalog=(uX4nHHSirBX1ScCSttzciogkxQ92)/catalog/example.catalog">https://prototypejungle.org/edit.html?catalog=(uX4nHHSirBX1ScCSttzciogkxQ92)/catalog/example.catalog</a>
</p>
<p>
will open the structure editor in  a mode where insertions are chosen from the given catalog. The catalog can be viewed at</p>
<p style="font-size:11pt">
<a href = "/catalogEdit.html?source=(uX4nHHSirBX1ScCSttzciogkxQ92)/catalog/example.catalog">https://prototypejungle.org/catalogEdit.html?source=(uX4nHHSirBX1ScCSttzciogkxQ92)/catalog/example.catalog</a>
</p>
<p>The code editor also uses catalogs, and
respects the same GET arguments as the structure editor (that is, <cw>catalog=</cw> and <cw>catalogExtension=</cw>).
</p>

<div class="section" id="visibility">14. Controlling Access to Properties</div>

<p> When an item is selected in the structure editor, its properties and those of its prototype are displayed in the right-hand panel. The default
is that <i>all</i> properties appear, but  some of the properties might be irrelevant to the user. Consider the basic
<a href="/edit.html?source=/shape/arrow.js">arrow</a> (click on the arrow to see its visible properties).
The <a href="/code.html?source=/shape/arrow.js">code</a> which implements it contains this line near the bottom:

<pre><code>
ui.hide(item,['head','shaft','end0','end1','direction','labelText','includeEndControls']);
</precode>

<p>The subsequent line:</p>

<pre  id="__setFieldType"><code>
item.__setFieldType('solidHead','boolean');
</precode>
<p>
causes the <cw>solidHead</cw> property to be displayed with a true/false selection box.
Similarly, in the  implementation of the <a href="/edit.html?source=/shape/shadedCircle.js">shadedCircle</a> , the line</p>

<pre id="setFieldType"> <code>
item.__setFieldType('outerFill','svg.Rgb');
</precode>
<p>
causes the <cw>outerFill</cw> property to be displayed with the <a href="https://bgrins.github.io/spectrum/">Spectrum color picker</a>. By default,this chooser is deployed for
all fields named <cw>fill</cw> or <cw>stroke</cw>.</p>

<p>By default, the values of properties are editable in the property panel. But with</p>


<pre id="uifreeze"><code>
ui.freeze(item,[property1,property2,...property<sup style="font-size:8pt">n</sup>]);
</precode>

<p> the given properties are presented in non-editable form.</p>


<div class="section" id="API">15. API </div>
<!--<p>This section supplies a short list of the stable calls  in this proof-of-concept. </p>-->

<p><i>(Partial listing - more to come)</i></p>
<p>Calls are given in the form <code>f(arg1:type1,arg2:type2...)</code> where types are: <code>string, number, Node (Array or Object) </code> or <code>any</code>. When a call
is described in more detail elsewhere in this document, a <a href="">link</a> is supplied.</p>

<div class="apiSection">Core</div>

<div class="apiCall">
  <div class="apiCallNm">pj.Object.mk()</div><div class="apiCallDf">Constructor for pj.Object</div>
</div>
<div class="apiCall">
  <div class="apiCallNm">pj.Array.mk()</div>
  <div class="apiCallDf">Constructor for pj.Array</div>
</div>
<!--<div class="apiCall">
  <div class="apiCallNm">pj.Object.addListener( nm:string; fn:function)</div>
 <div class="apiCallDf">Used in PrototypeJungle's simple event system. Documention pending.</div>
</div>-->
<div class="apiCall">
  <div class="apiCallNm">pj.Object.set(nm:string,vl:any)</div>
 <div class="apiCallDf">Assign vl as the child of <code>this</code></div>
</div>
<div class="apiCall">
  <div class="apiCallNm">pj.Object.remove(vl:Node)</div>
 <div class="apiCallDf">Remove <code>this</code> from the tree in which it appears.</div>
</div>
<div class="apiCall">
  <div class="apiCallNm">pj.Object.instantiate()</div>
 <div class="apiCallDf"><a href="#instantiation">Link</a>.</div>
</div>

<div class="apiCall">
  <div class="apiCallNm">pj.stringify(v:node)</div>
 <div class="apiCallDf"><a href="#serialization">Link</a>.</div>
</div>


<div class="apiCall">

 <div class="apiCallNm">pj.Object.__setFieldType(type:string)</div><div class="apiCallDf"><a href="#setFieldType">Link</a></div>
</div>
<!--
<div class="apiCall">
  <div class="apiCallNm">pj.Object.setData()</div>
 <div class="apiCallDf"><a href="#setData">Link</a>.</div>
</div>
<div class="apiCall">
  <div class="apiCallNm">pj.Object.outerUpdate()</div>
 <div class="apiCallDf"> Documention pending.</div>
</div>-->
<div class="apiCall">
  <div class="apiCallNm">pj.lift(o)</div>
 <div class="apiCallDf"><a href="#lift">Link</a>.</div>
</div>

<div class="apiCall">
  <div class="apiCallNm">pj.treeProperties( nd:Node, includeLeaves:boolean)</div>
 <div class="apiCallDf">Returns an array of the direct properties of <cw>nd</span> which are edges of the prototype tree.
 </div>
</div>

<div class="apiCall">
  <div class="apiCallNm">pj.declareComputed(nd:Object)</div>
 <div class="apiCallDf">Declare that <cw>nd</span> is generated by computation within an update method. The effect of this
is to delete  <cw>nd</span>  when the item is saved; updates are always run as the part of the restore process,
so  <cw>nd</span>  will be recomputed on restore. Computed content can be modified in the structure editor,  and these modifications will be retained through subsequent
updates, saves, and restores. The implementation keeps track of modifications, 
and, whenever an update is done, reapplies the modifications to the updated state. </div>
</div>

<div class="apiCall">
  <div class="apiCallNm">pj.Object.__setData(data:pj.Array)</div>
 <div class="apiCallDf">This is a simple utility for <a href="#spreads">spreads</a>. Its implementation is just:
 <cw>{this.__data=data;this.update();}</cw>
 </div>
</div>


<div class="apiSection">geom</div>

<div class="apiCall">
  <div class="apiCallNm">geom.Point.mk(x:number,y:number):<br/>geom.Point</div><div class="apiCallDf">Constructor for geom.Point, with properties x and y. If x and y are omitted, 0,0 are used.</div>
</div>


<div class="apiCall">
  <div class="apiCallNm">geom.Point.plus(p:geom.Point):<br/>geom.Point</div><div class="apiCallDf">Adds point p to this (vector addition)</div>
</div>


<div class="apiCall">
  <div class="apiCallNm">geom.Point.minus():geom.Point</div><div class="apiCallDf"><span class='codeWord'> = geom.Point.mk(-this.x,-this.y)</span></div>
</div>

<div class="apiCall">
  <div class="apiCallNm">geom.Point.difference(p:geom.Point):<br/>geom.Point</div><div class="apiCallDf"><span class='codeWord'> = this.plus(p.minus())</span></div>
</div>


<div class="apiCall">
  <div class="apiCallNm">geom.Point.times(v:number):geom.Point</div><div class="apiCallDf">Scales the point by v</div>
</div>


<div class="apiCall">
  <div class="apiCallNm">geom.toPoint(v:any):geom.Point</div><div class="apiCallDf">Creates a <cw>geom.Point</cw>  from several kinds of input. If <cw>v</cw>
  is an array <cw>[a,b]</cw> it returns a point with coordinates <cw>{x:a,y:b}</cw>; if <cw>v</cw> is a number, a point  with coordinates
  <cw>{x:v,y:0}</cw>,
  if v is a <cw>geom.Point</cw>, a copy of the point. <br/><cw>geom.toPoint()</cw> returns the point with coordinates <cw>{x:0,y:0}.</cw> </div>
</div>


<div class="apiCall">
  <div class="apiCallNm">geom.Rectangle.mk(corner:geom.Point,<br/> extent:geom.Point):geom.Rectangle</div><div class="apiCallDf">Constructor for geom.Rectangle, with properties corner and extent. For example <code>geom.Rectangle.mk(geom.Point.mk(10,20),geom.Point.mk(5,5))</code> has
  (10,20) as its upper-left corner, and (15,25) as its lower-right corner.</div>
</div>



<div class="apiCall">
  <div class="apiCallNm">geom.Transform.mk(<br/>translation:geom.Point,<br/> scale:number,<br/>rotation:number):<br/>
  geom.Transform</div><div class="apiCallDf">
  Constructor for geom.Transform, with properties translation, scale, and rotation. Rotation is in radians. All arguments are
  optional, defaulting to geom.Point.mk(0,0), 1, and 0, respectively.</div>
</div>

<div class="apiSection">svg</div>



<div class="apiCall">
  <div class="apiCallNm">svg.Element.mk(s:string)</div><div class="apiCallDf">Constructor for svg Elements. s is markup.</div>
</div>

<!--

<div class="apiCall">
  <div class="apiCallNm">svg.Element.bringToFront()</div><div class="apiCallDf">Transfers the element so that it is
  the last in the child list of its parent. This has the effect of displaying the element in front of its siblings.</div>
</div>
-->

<div class="apiCall">
  <div class="apiCallNm">svg.Element.__hide()</div><div class="apiCallDf">Self-explanatory.</div>
</div>


<div class="apiCall">
  <div class="apiCallNm">svg.Element.__show()</div><div class="apiCallDf">If an element has been hidden, change its status to "visible"</div>
</div>




<div class="apiCall">
  <div class="apiCallNm">svg.Element.__draw()</div><div class="apiCallDf">Refresh this element. Changes to the PrototypeJungle
  data for an element (and its descendents) are transferred to the svg model. Adding an element to the PrototypeJungle tree
  is not reflected </div>
</div>



<!--
<div class="apiCall">
  <div class="apiCallNm">svg.Root.mk(s:DomElement)</div><div class="apiCallDf">Constructor for a root of the svg model (with tag svg). DomElement should be an element on the current page, retrieved eg via document.getElementById("svgDiv"), to which the new
top-level svg element will be added. The content to be displayed should be set as the child named "contents" of this root.</div>
</div>


<div class="apiCall">
  <div class="apiCallNm">svg.Root.fitContents(v:number)</div><div class="apiCallDf">Arrange for the current contents of the
  svg model to appear centered in the viewing div, scaled into a box that is  fraction v of the available area (eg 0.9 if
  you wish at least a 5% boundary around the content.</div>
</div>
-->



<div class="apiCall">
  <div class="apiCallNm">svg.Element.__getTransform():<br/>geom.Transform</div><div class="apiCallDf">Returns the transform of this element.</div>
</div>


<div class="apiCall">
  <div class="apiCallNm">svg.Element.__setTransform(tr:<br/>geom.Transform)</div><div class="apiCallDf">Sets the transform of this element.</div>
</div>

<div class="apiCall">
  <div class="apiCallNm">svg.Element.__getTranslation():<br/>geom.Point</div><div class="apiCallDf">Returns the translation  of the svg transform of this element.</div>
</div>


<div class="apiCall">
  <div class="apiCallNm">svg.Element.__moveto(p:geom.Point)</div><div class="apiCallDf">Move this element to p. That is, set the translation  of the svg transform of this element to p.</div>
</div>


<div class="apiCall">
  <div class="apiCallNm">svg.Element.__getScale():number</div><div class="apiCallDf">Return the scale of the transform of this element.</div>
</div>

<div class="apiCall">
  <div class="apiCallNm">svg.Element.__setScale(s:number)</div><div class="apiCallDf">Set the scale 
   of the svg transform of this element to s.</div>
</div>






<div class="apiCall">
  <div class="apiCallNm">svg.Element.__bounds(rt:svg.Element):<br/>geom.Rectangle</div><div class="apiCallDf">Return the bounds
  of the given Element (and its descendants).  rt is optional. If
  rt is present, it should be an ancestor of this Element, and the bounds are given relative to rt's coordinate system. If
  rt is absent, bounds are given in the Element's own coordinate system.</div>
</div>


<div class="apiSection">ui</div>

<p>These calls control how property values are displayed in the structure editor.
 </p>


<div class="apiCall">
  <div class="apiCallNm">ui.hide(nd:Node,props:array of string)</div><div class="apiCallDf"> <a href="#visibility">Link</a></div>
</div>

<div class="apiCall">

 <div class="apiCallNm">ui.freeze(nd:Node,props:array of string)</div><div class="apiCallDf"> <a href="#uifreeze">Link</a></div>
</div>



<!--
<div class="apiCall">
  <div class="apiCallNm">ui.watch(nd:Node,props:array of string)</div><div class="apiCallDf">When any of the specified 
  properties of the specified node are modified in the inspector, run an update on the top level. </div>
</div>


<div class="apiCall">
  <div class="apiCallNm">ui.setNote(nd:Node,
  prop:string,note:string)</div><div class="apiCallDf">This supports a simple documentation scheme. It associates the given
  note with property prop of nd. In the inspector, prop will appear with a little "?" which, when clicked, will pop the note.
  </div>
</div>
-->


<div class="apiCall">


</div>



<div class="section" id="spreads">16. Spreads</div>

<p>Spreads are an aid to implementing diagrams in which a sequence of items is generated from  data,  with
one item per datum. Such items are conventionally called "marks" in infographic applications. An example is the
<a href="/edit.html?source=/forCatalog/graph.js">graph diagram</a>, in which
the incoming data consists of vertices and edges. Circles are generated for the former, and arrows for the latter. Spreads are not a core
feature of PrototypeJungle  but rather a coding assist for certain kinds of applications.</p>

<p>
A spread is constructed with:</p>
<precode>
pj.Spread.mk(prototype);
</precode>
<p>
The data associated
with a spread contains a sequence of individual data entities (eg numbers or points). The spread update method instantiates its prototype once for each
datum. Then a user-supplied method, <cw>bind</cw> adjusts each instantiation as appropriate for its datum.
  (That is, each spread has its own method for binding, but the update method is common to all).
In a graph diagram, the vertices and edges are represented as spreads.
The data  for the vertices
is a sequence of labeled positions, and the data for the edges is a sequence of to-from designations. See this
<a href="/repo1/data/sampleGraph.js">sample data file</a> - a require of the above mentioned
<a href="/edit.html?source=/forCatalog/graph.js">diagram</a>.</p>

<p> Here is the relevant code  in <a href="/repo1/diagram/graph.js">graph.js</a> for the spread of vertices:</p>

<precode>
  
item.set('vertices',pj.Spread.mk(item.circleP));
  
item.vertices.bind = function () {
  var data = this.__data;
  var n = data.length;
  for (var i=0;i&lt;n;i++) {
    var circle =  this.selectMark(i);
    circle.vertexId = data[i].id;
    circle.update();
    circle.__moveto(geom.toPoint(data[i].position));
  }
}
 
</precode>

<p style="padding-bottom:20px">The update method for spreads assumes that its data (a <cw>pj.Array</cw>) has been placed in its <cw>__data</cw> field.  Note that bind utilizes the
spread method <cw>selectMark(n)</cw> to select the nth  instantiation of the spread's prototype.</p>



{{endplate}}